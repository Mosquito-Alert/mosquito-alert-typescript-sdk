/* tslint:disable */
/* eslint-disable */
/**
 * Mosquito Alert API
 * Introducing API v1 for Mosquito Alert platform, a project desgined to facilitate citizen science initiatives and enable collaboration among scientists, public health officials, and environmental managers in the investigation and control of disease-carrying mosquitoes.
 *
 * The version of the OpenAPI document: v1
 * Contact: it@mosquitoalert.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { Annotation } from '../models';
// @ts-ignore
import type { AnnotationRequest } from '../models';
// @ts-ignore
import type { Assignment } from '../models';
// @ts-ignore
import type { CreatePhotoPrediction } from '../models';
// @ts-ignore
import type { CreatePhotoPredictionRequest } from '../models';
// @ts-ignore
import type { ErrorResponse401 } from '../models';
// @ts-ignore
import type { ErrorResponse403 } from '../models';
// @ts-ignore
import type { ErrorResponse404 } from '../models';
// @ts-ignore
import type { IdentificationTask } from '../models';
// @ts-ignore
import type { IdentificationtasksAnnotationsCreateValidationError } from '../models';
// @ts-ignore
import type { IdentificationtasksAnnotationsListClassificationConfidenceLabelParameter } from '../models';
// @ts-ignore
import type { IdentificationtasksAnnotationsListMineValidationError } from '../models';
// @ts-ignore
import type { IdentificationtasksAnnotationsListTypeParameter } from '../models';
// @ts-ignore
import type { IdentificationtasksAnnotationsListValidationError } from '../models';
// @ts-ignore
import type { IdentificationtasksListMineValidationError } from '../models';
// @ts-ignore
import type { IdentificationtasksListOrderByParameter } from '../models';
// @ts-ignore
import type { IdentificationtasksListResultSourceParameter } from '../models';
// @ts-ignore
import type { IdentificationtasksListReviewTypeParameter } from '../models';
// @ts-ignore
import type { IdentificationtasksListStatusParameter } from '../models';
// @ts-ignore
import type { IdentificationtasksListValidationError } from '../models';
// @ts-ignore
import type { IdentificationtasksPredictionsCreateValidationError } from '../models';
// @ts-ignore
import type { IdentificationtasksPredictionsPartialUpdateValidationError } from '../models';
// @ts-ignore
import type { IdentificationtasksPredictionsUpdateValidationError } from '../models';
// @ts-ignore
import type { PaginatedAnnotationList } from '../models';
// @ts-ignore
import type { PaginatedIdentificationTaskList } from '../models';
// @ts-ignore
import type { PaginatedPhotoPredictionList } from '../models';
// @ts-ignore
import type { PatchedPhotoPredictionRequest } from '../models';
// @ts-ignore
import type { PhotoPrediction } from '../models';
// @ts-ignore
import type { PhotoPredictionRequest } from '../models';
/**
 * IdentificationTasksApi - axios parameter creator
 * @export
 */
export const IdentificationTasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} observationUuid UUID of the Observation
         * @param {AnnotationRequest} annotationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsCreate: async (observationUuid: string, annotationRequest: AnnotationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'observationUuid' is not null or undefined
            assertParamExists('annotationsCreate', 'observationUuid', observationUuid)
            // verify required parameter 'annotationRequest' is not null or undefined
            assertParamExists('annotationsCreate', 'annotationRequest', annotationRequest)
            const localVarPath = `/identification-tasks/{observation_uuid}/annotations/`
                .replace(`{${"observation_uuid"}}`, encodeURIComponent(String(observationUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(annotationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} observationUuid UUID of the Observation
         * @param {IdentificationtasksAnnotationsListClassificationConfidenceLabelParameter} [classificationConfidenceLabel] 
         * @param {number} [classificationConfidenceMax] 
         * @param {number} [classificationConfidenceMin] 
         * @param {Array<number>} [classificationTaxonIds] 
         * @param {string} [createdAtAfter] Created at
         * @param {string} [createdAtBefore] Created at
         * @param {boolean} [isDecisive] 
         * @param {boolean} [isFavourite] 
         * @param {boolean} [isFlagged] 
         * @param {Array<IdentificationtasksListOrderByParameter>} [orderBy] Ordenado  
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {IdentificationtasksAnnotationsListTypeParameter} [type] 
         * @param {string} [updatedAtAfter] Updated at
         * @param {string} [updatedAtBefore] Updated at
         * @param {Array<number>} [userIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsList: async (observationUuid: string, classificationConfidenceLabel?: IdentificationtasksAnnotationsListClassificationConfidenceLabelParameter, classificationConfidenceMax?: number, classificationConfidenceMin?: number, classificationTaxonIds?: Array<number>, createdAtAfter?: string, createdAtBefore?: string, isDecisive?: boolean, isFavourite?: boolean, isFlagged?: boolean, orderBy?: Array<IdentificationtasksListOrderByParameter>, page?: number, pageSize?: number, type?: IdentificationtasksAnnotationsListTypeParameter, updatedAtAfter?: string, updatedAtBefore?: string, userIds?: Array<number>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'observationUuid' is not null or undefined
            assertParamExists('annotationsList', 'observationUuid', observationUuid)
            const localVarPath = `/identification-tasks/{observation_uuid}/annotations/`
                .replace(`{${"observation_uuid"}}`, encodeURIComponent(String(observationUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (classificationConfidenceLabel !== undefined) {
                localVarQueryParameter['classification_confidence_label'] = classificationConfidenceLabel;
            }

            if (classificationConfidenceMax !== undefined) {
                localVarQueryParameter['classification_confidence_max'] = classificationConfidenceMax;
            }

            if (classificationConfidenceMin !== undefined) {
                localVarQueryParameter['classification_confidence_min'] = classificationConfidenceMin;
            }

            if (classificationTaxonIds) {
                localVarQueryParameter['classification_taxon_ids'] = classificationTaxonIds;
            }

            if (createdAtAfter !== undefined) {
                localVarQueryParameter['created_at_after'] = (createdAtAfter as any instanceof Date) ?
                    (createdAtAfter as any).toISOString() :
                    createdAtAfter;
            }

            if (createdAtBefore !== undefined) {
                localVarQueryParameter['created_at_before'] = (createdAtBefore as any instanceof Date) ?
                    (createdAtBefore as any).toISOString() :
                    createdAtBefore;
            }

            if (isDecisive !== undefined) {
                localVarQueryParameter['is_decisive'] = isDecisive;
            }

            if (isFavourite !== undefined) {
                localVarQueryParameter['is_favourite'] = isFavourite;
            }

            if (isFlagged !== undefined) {
                localVarQueryParameter['is_flagged'] = isFlagged;
            }

            if (orderBy) {
                localVarQueryParameter['order_by'] = orderBy.join(COLLECTION_FORMATS.csv);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (updatedAtAfter !== undefined) {
                localVarQueryParameter['updated_at_after'] = (updatedAtAfter as any instanceof Date) ?
                    (updatedAtAfter as any).toISOString() :
                    updatedAtAfter;
            }

            if (updatedAtBefore !== undefined) {
                localVarQueryParameter['updated_at_before'] = (updatedAtBefore as any instanceof Date) ?
                    (updatedAtBefore as any).toISOString() :
                    updatedAtBefore;
            }

            if (userIds) {
                localVarQueryParameter['user_ids'] = userIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get my annotations
         * @param {IdentificationtasksAnnotationsListClassificationConfidenceLabelParameter} [classificationConfidenceLabel] 
         * @param {number} [classificationConfidenceMax] 
         * @param {number} [classificationConfidenceMin] 
         * @param {Array<number>} [classificationTaxonIds] 
         * @param {string} [createdAtAfter] Created at
         * @param {string} [createdAtBefore] Created at
         * @param {boolean} [isDecisive] 
         * @param {boolean} [isFavourite] 
         * @param {boolean} [isFlagged] 
         * @param {Array<IdentificationtasksListOrderByParameter>} [orderBy] Ordenado  
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {IdentificationtasksAnnotationsListTypeParameter} [type] 
         * @param {string} [updatedAtAfter] Updated at
         * @param {string} [updatedAtBefore] Updated at
         * @param {Array<number>} [userIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsListMine: async (classificationConfidenceLabel?: IdentificationtasksAnnotationsListClassificationConfidenceLabelParameter, classificationConfidenceMax?: number, classificationConfidenceMin?: number, classificationTaxonIds?: Array<number>, createdAtAfter?: string, createdAtBefore?: string, isDecisive?: boolean, isFavourite?: boolean, isFlagged?: boolean, orderBy?: Array<IdentificationtasksListOrderByParameter>, page?: number, pageSize?: number, type?: IdentificationtasksAnnotationsListTypeParameter, updatedAtAfter?: string, updatedAtBefore?: string, userIds?: Array<number>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me/identification-tasks/annotations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (classificationConfidenceLabel !== undefined) {
                localVarQueryParameter['classification_confidence_label'] = classificationConfidenceLabel;
            }

            if (classificationConfidenceMax !== undefined) {
                localVarQueryParameter['classification_confidence_max'] = classificationConfidenceMax;
            }

            if (classificationConfidenceMin !== undefined) {
                localVarQueryParameter['classification_confidence_min'] = classificationConfidenceMin;
            }

            if (classificationTaxonIds) {
                localVarQueryParameter['classification_taxon_ids'] = classificationTaxonIds;
            }

            if (createdAtAfter !== undefined) {
                localVarQueryParameter['created_at_after'] = (createdAtAfter as any instanceof Date) ?
                    (createdAtAfter as any).toISOString() :
                    createdAtAfter;
            }

            if (createdAtBefore !== undefined) {
                localVarQueryParameter['created_at_before'] = (createdAtBefore as any instanceof Date) ?
                    (createdAtBefore as any).toISOString() :
                    createdAtBefore;
            }

            if (isDecisive !== undefined) {
                localVarQueryParameter['is_decisive'] = isDecisive;
            }

            if (isFavourite !== undefined) {
                localVarQueryParameter['is_favourite'] = isFavourite;
            }

            if (isFlagged !== undefined) {
                localVarQueryParameter['is_flagged'] = isFlagged;
            }

            if (orderBy) {
                localVarQueryParameter['order_by'] = orderBy.join(COLLECTION_FORMATS.csv);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (updatedAtAfter !== undefined) {
                localVarQueryParameter['updated_at_after'] = (updatedAtAfter as any instanceof Date) ?
                    (updatedAtAfter as any).toISOString() :
                    updatedAtAfter;
            }

            if (updatedAtBefore !== undefined) {
                localVarQueryParameter['updated_at_before'] = (updatedAtBefore as any instanceof Date) ?
                    (updatedAtBefore as any).toISOString() :
                    updatedAtBefore;
            }

            if (userIds) {
                localVarQueryParameter['user_ids'] = userIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this expert report annotation.
         * @param {string} observationUuid UUID of the Observation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsRetrieve: async (id: number, observationUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('annotationsRetrieve', 'id', id)
            // verify required parameter 'observationUuid' is not null or undefined
            assertParamExists('annotationsRetrieve', 'observationUuid', observationUuid)
            const localVarPath = `/identification-tasks/{observation_uuid}/annotations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"observation_uuid"}}`, encodeURIComponent(String(observationUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign the next available identification task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignNext: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identification-tasks/assignments/next/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<number>} [annotatorIds] 
         * @param {Array<number>} [assigneeIds] 
         * @param {string} [createdAtAfter] Created at
         * @param {string} [createdAtBefore] Created at
         * @param {boolean} [fullyPredicted] Filters identification task based on whether all associated photos have predictions. Set to True to include identification tasks where every photo has a prediction; set to False to include identification tasks where at least one photo is missing a prediction.
         * @param {boolean} [isFlagged] 
         * @param {boolean} [isSafe] 
         * @param {number} [numAnnotationsMax] 
         * @param {number} [numAnnotationsMin] 
         * @param {Array<number>} [observationCountryIds] 
         * @param {Array<IdentificationtasksListOrderByParameter>} [orderBy] Ordenado  
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [resultAgreementMax] 
         * @param {number} [resultAgreementMin] 
         * @param {string} [resultConfidenceMax] 
         * @param {string} [resultConfidenceMin] 
         * @param {IdentificationtasksListResultSourceParameter} [resultSource] 
         * @param {Array<number>} [resultTaxonIds] 
         * @param {number} [resultUncertaintyMax] 
         * @param {number} [resultUncertaintyMin] 
         * @param {IdentificationtasksListReviewTypeParameter} [reviewType] 
         * @param {Array<IdentificationtasksListStatusParameter>} [status] 
         * @param {string} [updatedAtAfter] Update at
         * @param {string} [updatedAtBefore] Update at
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (annotatorIds?: Array<number>, assigneeIds?: Array<number>, createdAtAfter?: string, createdAtBefore?: string, fullyPredicted?: boolean, isFlagged?: boolean, isSafe?: boolean, numAnnotationsMax?: number, numAnnotationsMin?: number, observationCountryIds?: Array<number>, orderBy?: Array<IdentificationtasksListOrderByParameter>, page?: number, pageSize?: number, resultAgreementMax?: number, resultAgreementMin?: number, resultConfidenceMax?: string, resultConfidenceMin?: string, resultSource?: IdentificationtasksListResultSourceParameter, resultTaxonIds?: Array<number>, resultUncertaintyMax?: number, resultUncertaintyMin?: number, reviewType?: IdentificationtasksListReviewTypeParameter, status?: Array<IdentificationtasksListStatusParameter>, updatedAtAfter?: string, updatedAtBefore?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identification-tasks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (annotatorIds) {
                localVarQueryParameter['annotator_ids'] = annotatorIds;
            }

            if (assigneeIds) {
                localVarQueryParameter['assignee_ids'] = assigneeIds;
            }

            if (createdAtAfter !== undefined) {
                localVarQueryParameter['created_at_after'] = (createdAtAfter as any instanceof Date) ?
                    (createdAtAfter as any).toISOString() :
                    createdAtAfter;
            }

            if (createdAtBefore !== undefined) {
                localVarQueryParameter['created_at_before'] = (createdAtBefore as any instanceof Date) ?
                    (createdAtBefore as any).toISOString() :
                    createdAtBefore;
            }

            if (fullyPredicted !== undefined) {
                localVarQueryParameter['fully_predicted'] = fullyPredicted;
            }

            if (isFlagged !== undefined) {
                localVarQueryParameter['is_flagged'] = isFlagged;
            }

            if (isSafe !== undefined) {
                localVarQueryParameter['is_safe'] = isSafe;
            }

            if (numAnnotationsMax !== undefined) {
                localVarQueryParameter['num_annotations_max'] = numAnnotationsMax;
            }

            if (numAnnotationsMin !== undefined) {
                localVarQueryParameter['num_annotations_min'] = numAnnotationsMin;
            }

            if (observationCountryIds) {
                localVarQueryParameter['observation_country_ids'] = observationCountryIds;
            }

            if (orderBy) {
                localVarQueryParameter['order_by'] = orderBy.join(COLLECTION_FORMATS.csv);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (resultAgreementMax !== undefined) {
                localVarQueryParameter['result_agreement_max'] = resultAgreementMax;
            }

            if (resultAgreementMin !== undefined) {
                localVarQueryParameter['result_agreement_min'] = resultAgreementMin;
            }

            if (resultConfidenceMax !== undefined) {
                localVarQueryParameter['result_confidence_max'] = resultConfidenceMax;
            }

            if (resultConfidenceMin !== undefined) {
                localVarQueryParameter['result_confidence_min'] = resultConfidenceMin;
            }

            if (resultSource !== undefined) {
                localVarQueryParameter['result_source'] = resultSource;
            }

            if (resultTaxonIds) {
                localVarQueryParameter['result_taxon_ids'] = resultTaxonIds;
            }

            if (resultUncertaintyMax !== undefined) {
                localVarQueryParameter['result_uncertainty_max'] = resultUncertaintyMax;
            }

            if (resultUncertaintyMin !== undefined) {
                localVarQueryParameter['result_uncertainty_min'] = resultUncertaintyMin;
            }

            if (reviewType !== undefined) {
                localVarQueryParameter['review_type'] = reviewType;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (updatedAtAfter !== undefined) {
                localVarQueryParameter['updated_at_after'] = (updatedAtAfter as any instanceof Date) ?
                    (updatedAtAfter as any).toISOString() :
                    updatedAtAfter;
            }

            if (updatedAtBefore !== undefined) {
                localVarQueryParameter['updated_at_before'] = (updatedAtBefore as any instanceof Date) ?
                    (updatedAtBefore as any).toISOString() :
                    updatedAtBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get identification tasks annotated by me
         * @param {Array<number>} [annotatorIds] 
         * @param {Array<number>} [assigneeIds] 
         * @param {string} [createdAtAfter] Created at
         * @param {string} [createdAtBefore] Created at
         * @param {boolean} [fullyPredicted] Filters identification task based on whether all associated photos have predictions. Set to True to include identification tasks where every photo has a prediction; set to False to include identification tasks where at least one photo is missing a prediction.
         * @param {boolean} [isFlagged] 
         * @param {boolean} [isSafe] 
         * @param {number} [numAnnotationsMax] 
         * @param {number} [numAnnotationsMin] 
         * @param {Array<number>} [observationCountryIds] 
         * @param {Array<IdentificationtasksListOrderByParameter>} [orderBy] Ordenado  
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [resultAgreementMax] 
         * @param {number} [resultAgreementMin] 
         * @param {string} [resultConfidenceMax] 
         * @param {string} [resultConfidenceMin] 
         * @param {IdentificationtasksListResultSourceParameter} [resultSource] 
         * @param {Array<number>} [resultTaxonIds] 
         * @param {number} [resultUncertaintyMax] 
         * @param {number} [resultUncertaintyMin] 
         * @param {IdentificationtasksListReviewTypeParameter} [reviewType] 
         * @param {Array<IdentificationtasksListStatusParameter>} [status] 
         * @param {string} [updatedAtAfter] Update at
         * @param {string} [updatedAtBefore] Update at
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMine: async (annotatorIds?: Array<number>, assigneeIds?: Array<number>, createdAtAfter?: string, createdAtBefore?: string, fullyPredicted?: boolean, isFlagged?: boolean, isSafe?: boolean, numAnnotationsMax?: number, numAnnotationsMin?: number, observationCountryIds?: Array<number>, orderBy?: Array<IdentificationtasksListOrderByParameter>, page?: number, pageSize?: number, resultAgreementMax?: number, resultAgreementMin?: number, resultConfidenceMax?: string, resultConfidenceMin?: string, resultSource?: IdentificationtasksListResultSourceParameter, resultTaxonIds?: Array<number>, resultUncertaintyMax?: number, resultUncertaintyMin?: number, reviewType?: IdentificationtasksListReviewTypeParameter, status?: Array<IdentificationtasksListStatusParameter>, updatedAtAfter?: string, updatedAtBefore?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me/identification-tasks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (annotatorIds) {
                localVarQueryParameter['annotator_ids'] = annotatorIds;
            }

            if (assigneeIds) {
                localVarQueryParameter['assignee_ids'] = assigneeIds;
            }

            if (createdAtAfter !== undefined) {
                localVarQueryParameter['created_at_after'] = (createdAtAfter as any instanceof Date) ?
                    (createdAtAfter as any).toISOString() :
                    createdAtAfter;
            }

            if (createdAtBefore !== undefined) {
                localVarQueryParameter['created_at_before'] = (createdAtBefore as any instanceof Date) ?
                    (createdAtBefore as any).toISOString() :
                    createdAtBefore;
            }

            if (fullyPredicted !== undefined) {
                localVarQueryParameter['fully_predicted'] = fullyPredicted;
            }

            if (isFlagged !== undefined) {
                localVarQueryParameter['is_flagged'] = isFlagged;
            }

            if (isSafe !== undefined) {
                localVarQueryParameter['is_safe'] = isSafe;
            }

            if (numAnnotationsMax !== undefined) {
                localVarQueryParameter['num_annotations_max'] = numAnnotationsMax;
            }

            if (numAnnotationsMin !== undefined) {
                localVarQueryParameter['num_annotations_min'] = numAnnotationsMin;
            }

            if (observationCountryIds) {
                localVarQueryParameter['observation_country_ids'] = observationCountryIds;
            }

            if (orderBy) {
                localVarQueryParameter['order_by'] = orderBy.join(COLLECTION_FORMATS.csv);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (resultAgreementMax !== undefined) {
                localVarQueryParameter['result_agreement_max'] = resultAgreementMax;
            }

            if (resultAgreementMin !== undefined) {
                localVarQueryParameter['result_agreement_min'] = resultAgreementMin;
            }

            if (resultConfidenceMax !== undefined) {
                localVarQueryParameter['result_confidence_max'] = resultConfidenceMax;
            }

            if (resultConfidenceMin !== undefined) {
                localVarQueryParameter['result_confidence_min'] = resultConfidenceMin;
            }

            if (resultSource !== undefined) {
                localVarQueryParameter['result_source'] = resultSource;
            }

            if (resultTaxonIds) {
                localVarQueryParameter['result_taxon_ids'] = resultTaxonIds;
            }

            if (resultUncertaintyMax !== undefined) {
                localVarQueryParameter['result_uncertainty_max'] = resultUncertaintyMax;
            }

            if (resultUncertaintyMin !== undefined) {
                localVarQueryParameter['result_uncertainty_min'] = resultUncertaintyMin;
            }

            if (reviewType !== undefined) {
                localVarQueryParameter['review_type'] = reviewType;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (updatedAtAfter !== undefined) {
                localVarQueryParameter['updated_at_after'] = (updatedAtAfter as any instanceof Date) ?
                    (updatedAtAfter as any).toISOString() :
                    updatedAtAfter;
            }

            if (updatedAtBefore !== undefined) {
                localVarQueryParameter['updated_at_before'] = (updatedAtBefore as any instanceof Date) ?
                    (updatedAtBefore as any).toISOString() :
                    updatedAtBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} observationUuid UUID of the Observation
         * @param {CreatePhotoPredictionRequest} createPhotoPredictionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictionsCreate: async (observationUuid: string, createPhotoPredictionRequest: CreatePhotoPredictionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'observationUuid' is not null or undefined
            assertParamExists('predictionsCreate', 'observationUuid', observationUuid)
            // verify required parameter 'createPhotoPredictionRequest' is not null or undefined
            assertParamExists('predictionsCreate', 'createPhotoPredictionRequest', createPhotoPredictionRequest)
            const localVarPath = `/identification-tasks/{observation_uuid}/predictions/`
                .replace(`{${"observation_uuid"}}`, encodeURIComponent(String(observationUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPhotoPredictionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} observationUuid UUID of the Observation
         * @param {string} photoUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictionsDestroy: async (observationUuid: string, photoUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'observationUuid' is not null or undefined
            assertParamExists('predictionsDestroy', 'observationUuid', observationUuid)
            // verify required parameter 'photoUuid' is not null or undefined
            assertParamExists('predictionsDestroy', 'photoUuid', photoUuid)
            const localVarPath = `/identification-tasks/{observation_uuid}/predictions/{photo_uuid}/`
                .replace(`{${"observation_uuid"}}`, encodeURIComponent(String(observationUuid)))
                .replace(`{${"photo_uuid"}}`, encodeURIComponent(String(photoUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} observationUuid UUID of the Observation
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictionsList: async (observationUuid: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'observationUuid' is not null or undefined
            assertParamExists('predictionsList', 'observationUuid', observationUuid)
            const localVarPath = `/identification-tasks/{observation_uuid}/predictions/`
                .replace(`{${"observation_uuid"}}`, encodeURIComponent(String(observationUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} observationUuid UUID of the Observation
         * @param {string} photoUuid 
         * @param {PatchedPhotoPredictionRequest} [patchedPhotoPredictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictionsPartialUpdate: async (observationUuid: string, photoUuid: string, patchedPhotoPredictionRequest?: PatchedPhotoPredictionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'observationUuid' is not null or undefined
            assertParamExists('predictionsPartialUpdate', 'observationUuid', observationUuid)
            // verify required parameter 'photoUuid' is not null or undefined
            assertParamExists('predictionsPartialUpdate', 'photoUuid', photoUuid)
            const localVarPath = `/identification-tasks/{observation_uuid}/predictions/{photo_uuid}/`
                .replace(`{${"observation_uuid"}}`, encodeURIComponent(String(observationUuid)))
                .replace(`{${"photo_uuid"}}`, encodeURIComponent(String(photoUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPhotoPredictionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} observationUuid UUID of the Observation
         * @param {string} photoUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictionsRetrieve: async (observationUuid: string, photoUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'observationUuid' is not null or undefined
            assertParamExists('predictionsRetrieve', 'observationUuid', observationUuid)
            // verify required parameter 'photoUuid' is not null or undefined
            assertParamExists('predictionsRetrieve', 'photoUuid', photoUuid)
            const localVarPath = `/identification-tasks/{observation_uuid}/predictions/{photo_uuid}/`
                .replace(`{${"observation_uuid"}}`, encodeURIComponent(String(observationUuid)))
                .replace(`{${"photo_uuid"}}`, encodeURIComponent(String(photoUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} observationUuid UUID of the Observation
         * @param {string} photoUuid 
         * @param {PhotoPredictionRequest} photoPredictionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictionsUpdate: async (observationUuid: string, photoUuid: string, photoPredictionRequest: PhotoPredictionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'observationUuid' is not null or undefined
            assertParamExists('predictionsUpdate', 'observationUuid', observationUuid)
            // verify required parameter 'photoUuid' is not null or undefined
            assertParamExists('predictionsUpdate', 'photoUuid', photoUuid)
            // verify required parameter 'photoPredictionRequest' is not null or undefined
            assertParamExists('predictionsUpdate', 'photoPredictionRequest', photoPredictionRequest)
            const localVarPath = `/identification-tasks/{observation_uuid}/predictions/{photo_uuid}/`
                .replace(`{${"observation_uuid"}}`, encodeURIComponent(String(observationUuid)))
                .replace(`{${"photo_uuid"}}`, encodeURIComponent(String(photoUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(photoPredictionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} observationUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (observationUuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'observationUuid' is not null or undefined
            assertParamExists('retrieve', 'observationUuid', observationUuid)
            const localVarPath = `/identification-tasks/{observation_uuid}/`
                .replace(`{${"observation_uuid"}}`, encodeURIComponent(String(observationUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdentificationTasksApi - functional programming interface
 * @export
 */
export const IdentificationTasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdentificationTasksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} observationUuid UUID of the Observation
         * @param {AnnotationRequest} annotationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationsCreate(observationUuid: string, annotationRequest: AnnotationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Annotation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationsCreate(observationUuid, annotationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentificationTasksApi.annotationsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} observationUuid UUID of the Observation
         * @param {IdentificationtasksAnnotationsListClassificationConfidenceLabelParameter} [classificationConfidenceLabel] 
         * @param {number} [classificationConfidenceMax] 
         * @param {number} [classificationConfidenceMin] 
         * @param {Array<number>} [classificationTaxonIds] 
         * @param {string} [createdAtAfter] Created at
         * @param {string} [createdAtBefore] Created at
         * @param {boolean} [isDecisive] 
         * @param {boolean} [isFavourite] 
         * @param {boolean} [isFlagged] 
         * @param {Array<IdentificationtasksListOrderByParameter>} [orderBy] Ordenado  
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {IdentificationtasksAnnotationsListTypeParameter} [type] 
         * @param {string} [updatedAtAfter] Updated at
         * @param {string} [updatedAtBefore] Updated at
         * @param {Array<number>} [userIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationsList(observationUuid: string, classificationConfidenceLabel?: IdentificationtasksAnnotationsListClassificationConfidenceLabelParameter, classificationConfidenceMax?: number, classificationConfidenceMin?: number, classificationTaxonIds?: Array<number>, createdAtAfter?: string, createdAtBefore?: string, isDecisive?: boolean, isFavourite?: boolean, isFlagged?: boolean, orderBy?: Array<IdentificationtasksListOrderByParameter>, page?: number, pageSize?: number, type?: IdentificationtasksAnnotationsListTypeParameter, updatedAtAfter?: string, updatedAtBefore?: string, userIds?: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAnnotationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationsList(observationUuid, classificationConfidenceLabel, classificationConfidenceMax, classificationConfidenceMin, classificationTaxonIds, createdAtAfter, createdAtBefore, isDecisive, isFavourite, isFlagged, orderBy, page, pageSize, type, updatedAtAfter, updatedAtBefore, userIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentificationTasksApi.annotationsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get my annotations
         * @param {IdentificationtasksAnnotationsListClassificationConfidenceLabelParameter} [classificationConfidenceLabel] 
         * @param {number} [classificationConfidenceMax] 
         * @param {number} [classificationConfidenceMin] 
         * @param {Array<number>} [classificationTaxonIds] 
         * @param {string} [createdAtAfter] Created at
         * @param {string} [createdAtBefore] Created at
         * @param {boolean} [isDecisive] 
         * @param {boolean} [isFavourite] 
         * @param {boolean} [isFlagged] 
         * @param {Array<IdentificationtasksListOrderByParameter>} [orderBy] Ordenado  
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {IdentificationtasksAnnotationsListTypeParameter} [type] 
         * @param {string} [updatedAtAfter] Updated at
         * @param {string} [updatedAtBefore] Updated at
         * @param {Array<number>} [userIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationsListMine(classificationConfidenceLabel?: IdentificationtasksAnnotationsListClassificationConfidenceLabelParameter, classificationConfidenceMax?: number, classificationConfidenceMin?: number, classificationTaxonIds?: Array<number>, createdAtAfter?: string, createdAtBefore?: string, isDecisive?: boolean, isFavourite?: boolean, isFlagged?: boolean, orderBy?: Array<IdentificationtasksListOrderByParameter>, page?: number, pageSize?: number, type?: IdentificationtasksAnnotationsListTypeParameter, updatedAtAfter?: string, updatedAtBefore?: string, userIds?: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAnnotationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationsListMine(classificationConfidenceLabel, classificationConfidenceMax, classificationConfidenceMin, classificationTaxonIds, createdAtAfter, createdAtBefore, isDecisive, isFavourite, isFlagged, orderBy, page, pageSize, type, updatedAtAfter, updatedAtBefore, userIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentificationTasksApi.annotationsListMine']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this expert report annotation.
         * @param {string} observationUuid UUID of the Observation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationsRetrieve(id: number, observationUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Annotation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationsRetrieve(id, observationUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentificationTasksApi.annotationsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assign the next available identification task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignNext(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Assignment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignNext(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentificationTasksApi.assignNext']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Array<number>} [annotatorIds] 
         * @param {Array<number>} [assigneeIds] 
         * @param {string} [createdAtAfter] Created at
         * @param {string} [createdAtBefore] Created at
         * @param {boolean} [fullyPredicted] Filters identification task based on whether all associated photos have predictions. Set to True to include identification tasks where every photo has a prediction; set to False to include identification tasks where at least one photo is missing a prediction.
         * @param {boolean} [isFlagged] 
         * @param {boolean} [isSafe] 
         * @param {number} [numAnnotationsMax] 
         * @param {number} [numAnnotationsMin] 
         * @param {Array<number>} [observationCountryIds] 
         * @param {Array<IdentificationtasksListOrderByParameter>} [orderBy] Ordenado  
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [resultAgreementMax] 
         * @param {number} [resultAgreementMin] 
         * @param {string} [resultConfidenceMax] 
         * @param {string} [resultConfidenceMin] 
         * @param {IdentificationtasksListResultSourceParameter} [resultSource] 
         * @param {Array<number>} [resultTaxonIds] 
         * @param {number} [resultUncertaintyMax] 
         * @param {number} [resultUncertaintyMin] 
         * @param {IdentificationtasksListReviewTypeParameter} [reviewType] 
         * @param {Array<IdentificationtasksListStatusParameter>} [status] 
         * @param {string} [updatedAtAfter] Update at
         * @param {string} [updatedAtBefore] Update at
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(annotatorIds?: Array<number>, assigneeIds?: Array<number>, createdAtAfter?: string, createdAtBefore?: string, fullyPredicted?: boolean, isFlagged?: boolean, isSafe?: boolean, numAnnotationsMax?: number, numAnnotationsMin?: number, observationCountryIds?: Array<number>, orderBy?: Array<IdentificationtasksListOrderByParameter>, page?: number, pageSize?: number, resultAgreementMax?: number, resultAgreementMin?: number, resultConfidenceMax?: string, resultConfidenceMin?: string, resultSource?: IdentificationtasksListResultSourceParameter, resultTaxonIds?: Array<number>, resultUncertaintyMax?: number, resultUncertaintyMin?: number, reviewType?: IdentificationtasksListReviewTypeParameter, status?: Array<IdentificationtasksListStatusParameter>, updatedAtAfter?: string, updatedAtBefore?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedIdentificationTaskList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(annotatorIds, assigneeIds, createdAtAfter, createdAtBefore, fullyPredicted, isFlagged, isSafe, numAnnotationsMax, numAnnotationsMin, observationCountryIds, orderBy, page, pageSize, resultAgreementMax, resultAgreementMin, resultConfidenceMax, resultConfidenceMin, resultSource, resultTaxonIds, resultUncertaintyMax, resultUncertaintyMin, reviewType, status, updatedAtAfter, updatedAtBefore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentificationTasksApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get identification tasks annotated by me
         * @param {Array<number>} [annotatorIds] 
         * @param {Array<number>} [assigneeIds] 
         * @param {string} [createdAtAfter] Created at
         * @param {string} [createdAtBefore] Created at
         * @param {boolean} [fullyPredicted] Filters identification task based on whether all associated photos have predictions. Set to True to include identification tasks where every photo has a prediction; set to False to include identification tasks where at least one photo is missing a prediction.
         * @param {boolean} [isFlagged] 
         * @param {boolean} [isSafe] 
         * @param {number} [numAnnotationsMax] 
         * @param {number} [numAnnotationsMin] 
         * @param {Array<number>} [observationCountryIds] 
         * @param {Array<IdentificationtasksListOrderByParameter>} [orderBy] Ordenado  
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [resultAgreementMax] 
         * @param {number} [resultAgreementMin] 
         * @param {string} [resultConfidenceMax] 
         * @param {string} [resultConfidenceMin] 
         * @param {IdentificationtasksListResultSourceParameter} [resultSource] 
         * @param {Array<number>} [resultTaxonIds] 
         * @param {number} [resultUncertaintyMax] 
         * @param {number} [resultUncertaintyMin] 
         * @param {IdentificationtasksListReviewTypeParameter} [reviewType] 
         * @param {Array<IdentificationtasksListStatusParameter>} [status] 
         * @param {string} [updatedAtAfter] Update at
         * @param {string} [updatedAtBefore] Update at
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMine(annotatorIds?: Array<number>, assigneeIds?: Array<number>, createdAtAfter?: string, createdAtBefore?: string, fullyPredicted?: boolean, isFlagged?: boolean, isSafe?: boolean, numAnnotationsMax?: number, numAnnotationsMin?: number, observationCountryIds?: Array<number>, orderBy?: Array<IdentificationtasksListOrderByParameter>, page?: number, pageSize?: number, resultAgreementMax?: number, resultAgreementMin?: number, resultConfidenceMax?: string, resultConfidenceMin?: string, resultSource?: IdentificationtasksListResultSourceParameter, resultTaxonIds?: Array<number>, resultUncertaintyMax?: number, resultUncertaintyMin?: number, reviewType?: IdentificationtasksListReviewTypeParameter, status?: Array<IdentificationtasksListStatusParameter>, updatedAtAfter?: string, updatedAtBefore?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedIdentificationTaskList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMine(annotatorIds, assigneeIds, createdAtAfter, createdAtBefore, fullyPredicted, isFlagged, isSafe, numAnnotationsMax, numAnnotationsMin, observationCountryIds, orderBy, page, pageSize, resultAgreementMax, resultAgreementMin, resultConfidenceMax, resultConfidenceMin, resultSource, resultTaxonIds, resultUncertaintyMax, resultUncertaintyMin, reviewType, status, updatedAtAfter, updatedAtBefore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentificationTasksApi.listMine']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} observationUuid UUID of the Observation
         * @param {CreatePhotoPredictionRequest} createPhotoPredictionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async predictionsCreate(observationUuid: string, createPhotoPredictionRequest: CreatePhotoPredictionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePhotoPrediction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.predictionsCreate(observationUuid, createPhotoPredictionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentificationTasksApi.predictionsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} observationUuid UUID of the Observation
         * @param {string} photoUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async predictionsDestroy(observationUuid: string, photoUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.predictionsDestroy(observationUuid, photoUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentificationTasksApi.predictionsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} observationUuid UUID of the Observation
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async predictionsList(observationUuid: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPhotoPredictionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.predictionsList(observationUuid, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentificationTasksApi.predictionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} observationUuid UUID of the Observation
         * @param {string} photoUuid 
         * @param {PatchedPhotoPredictionRequest} [patchedPhotoPredictionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async predictionsPartialUpdate(observationUuid: string, photoUuid: string, patchedPhotoPredictionRequest?: PatchedPhotoPredictionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PhotoPrediction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.predictionsPartialUpdate(observationUuid, photoUuid, patchedPhotoPredictionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentificationTasksApi.predictionsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} observationUuid UUID of the Observation
         * @param {string} photoUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async predictionsRetrieve(observationUuid: string, photoUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PhotoPrediction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.predictionsRetrieve(observationUuid, photoUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentificationTasksApi.predictionsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} observationUuid UUID of the Observation
         * @param {string} photoUuid 
         * @param {PhotoPredictionRequest} photoPredictionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async predictionsUpdate(observationUuid: string, photoUuid: string, photoPredictionRequest: PhotoPredictionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PhotoPrediction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.predictionsUpdate(observationUuid, photoUuid, photoPredictionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentificationTasksApi.predictionsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} observationUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(observationUuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentificationTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(observationUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentificationTasksApi.retrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IdentificationTasksApi - factory interface
 * @export
 */
export const IdentificationTasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdentificationTasksApiFp(configuration)
    return {
        /**
         * 
         * @param {IdentificationTasksApiAnnotationsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsCreate(requestParameters: IdentificationTasksApiAnnotationsCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Annotation> {
            return localVarFp.annotationsCreate(requestParameters.observationUuid, requestParameters.annotationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {IdentificationTasksApiAnnotationsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsList(requestParameters: IdentificationTasksApiAnnotationsListRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedAnnotationList> {
            return localVarFp.annotationsList(requestParameters.observationUuid, requestParameters.classificationConfidenceLabel, requestParameters.classificationConfidenceMax, requestParameters.classificationConfidenceMin, requestParameters.classificationTaxonIds, requestParameters.createdAtAfter, requestParameters.createdAtBefore, requestParameters.isDecisive, requestParameters.isFavourite, requestParameters.isFlagged, requestParameters.orderBy, requestParameters.page, requestParameters.pageSize, requestParameters.type, requestParameters.updatedAtAfter, requestParameters.updatedAtBefore, requestParameters.userIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Get my annotations
         * @param {IdentificationTasksApiAnnotationsListMineRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsListMine(requestParameters: IdentificationTasksApiAnnotationsListMineRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedAnnotationList> {
            return localVarFp.annotationsListMine(requestParameters.classificationConfidenceLabel, requestParameters.classificationConfidenceMax, requestParameters.classificationConfidenceMin, requestParameters.classificationTaxonIds, requestParameters.createdAtAfter, requestParameters.createdAtBefore, requestParameters.isDecisive, requestParameters.isFavourite, requestParameters.isFlagged, requestParameters.orderBy, requestParameters.page, requestParameters.pageSize, requestParameters.type, requestParameters.updatedAtAfter, requestParameters.updatedAtBefore, requestParameters.userIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {IdentificationTasksApiAnnotationsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsRetrieve(requestParameters: IdentificationTasksApiAnnotationsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<Annotation> {
            return localVarFp.annotationsRetrieve(requestParameters.id, requestParameters.observationUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign the next available identification task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignNext(options?: RawAxiosRequestConfig): AxiosPromise<Assignment> {
            return localVarFp.assignNext(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {IdentificationTasksApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(requestParameters: IdentificationTasksApiListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedIdentificationTaskList> {
            return localVarFp.list(requestParameters.annotatorIds, requestParameters.assigneeIds, requestParameters.createdAtAfter, requestParameters.createdAtBefore, requestParameters.fullyPredicted, requestParameters.isFlagged, requestParameters.isSafe, requestParameters.numAnnotationsMax, requestParameters.numAnnotationsMin, requestParameters.observationCountryIds, requestParameters.orderBy, requestParameters.page, requestParameters.pageSize, requestParameters.resultAgreementMax, requestParameters.resultAgreementMin, requestParameters.resultConfidenceMax, requestParameters.resultConfidenceMin, requestParameters.resultSource, requestParameters.resultTaxonIds, requestParameters.resultUncertaintyMax, requestParameters.resultUncertaintyMin, requestParameters.reviewType, requestParameters.status, requestParameters.updatedAtAfter, requestParameters.updatedAtBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Get identification tasks annotated by me
         * @param {IdentificationTasksApiListMineRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMine(requestParameters: IdentificationTasksApiListMineRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedIdentificationTaskList> {
            return localVarFp.listMine(requestParameters.annotatorIds, requestParameters.assigneeIds, requestParameters.createdAtAfter, requestParameters.createdAtBefore, requestParameters.fullyPredicted, requestParameters.isFlagged, requestParameters.isSafe, requestParameters.numAnnotationsMax, requestParameters.numAnnotationsMin, requestParameters.observationCountryIds, requestParameters.orderBy, requestParameters.page, requestParameters.pageSize, requestParameters.resultAgreementMax, requestParameters.resultAgreementMin, requestParameters.resultConfidenceMax, requestParameters.resultConfidenceMin, requestParameters.resultSource, requestParameters.resultTaxonIds, requestParameters.resultUncertaintyMax, requestParameters.resultUncertaintyMin, requestParameters.reviewType, requestParameters.status, requestParameters.updatedAtAfter, requestParameters.updatedAtBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {IdentificationTasksApiPredictionsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictionsCreate(requestParameters: IdentificationTasksApiPredictionsCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreatePhotoPrediction> {
            return localVarFp.predictionsCreate(requestParameters.observationUuid, requestParameters.createPhotoPredictionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {IdentificationTasksApiPredictionsDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictionsDestroy(requestParameters: IdentificationTasksApiPredictionsDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.predictionsDestroy(requestParameters.observationUuid, requestParameters.photoUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {IdentificationTasksApiPredictionsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictionsList(requestParameters: IdentificationTasksApiPredictionsListRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPhotoPredictionList> {
            return localVarFp.predictionsList(requestParameters.observationUuid, requestParameters.page, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {IdentificationTasksApiPredictionsPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictionsPartialUpdate(requestParameters: IdentificationTasksApiPredictionsPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<PhotoPrediction> {
            return localVarFp.predictionsPartialUpdate(requestParameters.observationUuid, requestParameters.photoUuid, requestParameters.patchedPhotoPredictionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {IdentificationTasksApiPredictionsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictionsRetrieve(requestParameters: IdentificationTasksApiPredictionsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<PhotoPrediction> {
            return localVarFp.predictionsRetrieve(requestParameters.observationUuid, requestParameters.photoUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {IdentificationTasksApiPredictionsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictionsUpdate(requestParameters: IdentificationTasksApiPredictionsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<PhotoPrediction> {
            return localVarFp.predictionsUpdate(requestParameters.observationUuid, requestParameters.photoUuid, requestParameters.photoPredictionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {IdentificationTasksApiRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(requestParameters: IdentificationTasksApiRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<IdentificationTask> {
            return localVarFp.retrieve(requestParameters.observationUuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for annotationsCreate operation in IdentificationTasksApi.
 * @export
 * @interface IdentificationTasksApiAnnotationsCreateRequest
 */
export interface IdentificationTasksApiAnnotationsCreateRequest {
    /**
     * UUID of the Observation
     * @type {string}
     * @memberof IdentificationTasksApiAnnotationsCreate
     */
    readonly observationUuid: string

    /**
     * 
     * @type {AnnotationRequest}
     * @memberof IdentificationTasksApiAnnotationsCreate
     */
    readonly annotationRequest: AnnotationRequest
}

/**
 * Request parameters for annotationsList operation in IdentificationTasksApi.
 * @export
 * @interface IdentificationTasksApiAnnotationsListRequest
 */
export interface IdentificationTasksApiAnnotationsListRequest {
    /**
     * UUID of the Observation
     * @type {string}
     * @memberof IdentificationTasksApiAnnotationsList
     */
    readonly observationUuid: string

    /**
     * 
     * @type {IdentificationtasksAnnotationsListClassificationConfidenceLabelParameter}
     * @memberof IdentificationTasksApiAnnotationsList
     */
    readonly classificationConfidenceLabel?: IdentificationtasksAnnotationsListClassificationConfidenceLabelParameter

    /**
     * 
     * @type {number}
     * @memberof IdentificationTasksApiAnnotationsList
     */
    readonly classificationConfidenceMax?: number

    /**
     * 
     * @type {number}
     * @memberof IdentificationTasksApiAnnotationsList
     */
    readonly classificationConfidenceMin?: number

    /**
     * 
     * @type {Array<number>}
     * @memberof IdentificationTasksApiAnnotationsList
     */
    readonly classificationTaxonIds?: Array<number>

    /**
     * Created at
     * @type {string}
     * @memberof IdentificationTasksApiAnnotationsList
     */
    readonly createdAtAfter?: string

    /**
     * Created at
     * @type {string}
     * @memberof IdentificationTasksApiAnnotationsList
     */
    readonly createdAtBefore?: string

    /**
     * 
     * @type {boolean}
     * @memberof IdentificationTasksApiAnnotationsList
     */
    readonly isDecisive?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof IdentificationTasksApiAnnotationsList
     */
    readonly isFavourite?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof IdentificationTasksApiAnnotationsList
     */
    readonly isFlagged?: boolean

    /**
     * Ordenado  
     * @type {Array<IdentificationtasksListOrderByParameter>}
     * @memberof IdentificationTasksApiAnnotationsList
     */
    readonly orderBy?: Array<IdentificationtasksListOrderByParameter>

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof IdentificationTasksApiAnnotationsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof IdentificationTasksApiAnnotationsList
     */
    readonly pageSize?: number

    /**
     * 
     * @type {IdentificationtasksAnnotationsListTypeParameter}
     * @memberof IdentificationTasksApiAnnotationsList
     */
    readonly type?: IdentificationtasksAnnotationsListTypeParameter

    /**
     * Updated at
     * @type {string}
     * @memberof IdentificationTasksApiAnnotationsList
     */
    readonly updatedAtAfter?: string

    /**
     * Updated at
     * @type {string}
     * @memberof IdentificationTasksApiAnnotationsList
     */
    readonly updatedAtBefore?: string

    /**
     * 
     * @type {Array<number>}
     * @memberof IdentificationTasksApiAnnotationsList
     */
    readonly userIds?: Array<number>
}

/**
 * Request parameters for annotationsListMine operation in IdentificationTasksApi.
 * @export
 * @interface IdentificationTasksApiAnnotationsListMineRequest
 */
export interface IdentificationTasksApiAnnotationsListMineRequest {
    /**
     * 
     * @type {IdentificationtasksAnnotationsListClassificationConfidenceLabelParameter}
     * @memberof IdentificationTasksApiAnnotationsListMine
     */
    readonly classificationConfidenceLabel?: IdentificationtasksAnnotationsListClassificationConfidenceLabelParameter

    /**
     * 
     * @type {number}
     * @memberof IdentificationTasksApiAnnotationsListMine
     */
    readonly classificationConfidenceMax?: number

    /**
     * 
     * @type {number}
     * @memberof IdentificationTasksApiAnnotationsListMine
     */
    readonly classificationConfidenceMin?: number

    /**
     * 
     * @type {Array<number>}
     * @memberof IdentificationTasksApiAnnotationsListMine
     */
    readonly classificationTaxonIds?: Array<number>

    /**
     * Created at
     * @type {string}
     * @memberof IdentificationTasksApiAnnotationsListMine
     */
    readonly createdAtAfter?: string

    /**
     * Created at
     * @type {string}
     * @memberof IdentificationTasksApiAnnotationsListMine
     */
    readonly createdAtBefore?: string

    /**
     * 
     * @type {boolean}
     * @memberof IdentificationTasksApiAnnotationsListMine
     */
    readonly isDecisive?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof IdentificationTasksApiAnnotationsListMine
     */
    readonly isFavourite?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof IdentificationTasksApiAnnotationsListMine
     */
    readonly isFlagged?: boolean

    /**
     * Ordenado  
     * @type {Array<IdentificationtasksListOrderByParameter>}
     * @memberof IdentificationTasksApiAnnotationsListMine
     */
    readonly orderBy?: Array<IdentificationtasksListOrderByParameter>

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof IdentificationTasksApiAnnotationsListMine
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof IdentificationTasksApiAnnotationsListMine
     */
    readonly pageSize?: number

    /**
     * 
     * @type {IdentificationtasksAnnotationsListTypeParameter}
     * @memberof IdentificationTasksApiAnnotationsListMine
     */
    readonly type?: IdentificationtasksAnnotationsListTypeParameter

    /**
     * Updated at
     * @type {string}
     * @memberof IdentificationTasksApiAnnotationsListMine
     */
    readonly updatedAtAfter?: string

    /**
     * Updated at
     * @type {string}
     * @memberof IdentificationTasksApiAnnotationsListMine
     */
    readonly updatedAtBefore?: string

    /**
     * 
     * @type {Array<number>}
     * @memberof IdentificationTasksApiAnnotationsListMine
     */
    readonly userIds?: Array<number>
}

/**
 * Request parameters for annotationsRetrieve operation in IdentificationTasksApi.
 * @export
 * @interface IdentificationTasksApiAnnotationsRetrieveRequest
 */
export interface IdentificationTasksApiAnnotationsRetrieveRequest {
    /**
     * A unique integer value identifying this expert report annotation.
     * @type {number}
     * @memberof IdentificationTasksApiAnnotationsRetrieve
     */
    readonly id: number

    /**
     * UUID of the Observation
     * @type {string}
     * @memberof IdentificationTasksApiAnnotationsRetrieve
     */
    readonly observationUuid: string
}

/**
 * Request parameters for list operation in IdentificationTasksApi.
 * @export
 * @interface IdentificationTasksApiListRequest
 */
export interface IdentificationTasksApiListRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof IdentificationTasksApiList
     */
    readonly annotatorIds?: Array<number>

    /**
     * 
     * @type {Array<number>}
     * @memberof IdentificationTasksApiList
     */
    readonly assigneeIds?: Array<number>

    /**
     * Created at
     * @type {string}
     * @memberof IdentificationTasksApiList
     */
    readonly createdAtAfter?: string

    /**
     * Created at
     * @type {string}
     * @memberof IdentificationTasksApiList
     */
    readonly createdAtBefore?: string

    /**
     * Filters identification task based on whether all associated photos have predictions. Set to True to include identification tasks where every photo has a prediction; set to False to include identification tasks where at least one photo is missing a prediction.
     * @type {boolean}
     * @memberof IdentificationTasksApiList
     */
    readonly fullyPredicted?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof IdentificationTasksApiList
     */
    readonly isFlagged?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof IdentificationTasksApiList
     */
    readonly isSafe?: boolean

    /**
     * 
     * @type {number}
     * @memberof IdentificationTasksApiList
     */
    readonly numAnnotationsMax?: number

    /**
     * 
     * @type {number}
     * @memberof IdentificationTasksApiList
     */
    readonly numAnnotationsMin?: number

    /**
     * 
     * @type {Array<number>}
     * @memberof IdentificationTasksApiList
     */
    readonly observationCountryIds?: Array<number>

    /**
     * Ordenado  
     * @type {Array<IdentificationtasksListOrderByParameter>}
     * @memberof IdentificationTasksApiList
     */
    readonly orderBy?: Array<IdentificationtasksListOrderByParameter>

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof IdentificationTasksApiList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof IdentificationTasksApiList
     */
    readonly pageSize?: number

    /**
     * 
     * @type {number}
     * @memberof IdentificationTasksApiList
     */
    readonly resultAgreementMax?: number

    /**
     * 
     * @type {number}
     * @memberof IdentificationTasksApiList
     */
    readonly resultAgreementMin?: number

    /**
     * 
     * @type {string}
     * @memberof IdentificationTasksApiList
     */
    readonly resultConfidenceMax?: string

    /**
     * 
     * @type {string}
     * @memberof IdentificationTasksApiList
     */
    readonly resultConfidenceMin?: string

    /**
     * 
     * @type {IdentificationtasksListResultSourceParameter}
     * @memberof IdentificationTasksApiList
     */
    readonly resultSource?: IdentificationtasksListResultSourceParameter

    /**
     * 
     * @type {Array<number>}
     * @memberof IdentificationTasksApiList
     */
    readonly resultTaxonIds?: Array<number>

    /**
     * 
     * @type {number}
     * @memberof IdentificationTasksApiList
     */
    readonly resultUncertaintyMax?: number

    /**
     * 
     * @type {number}
     * @memberof IdentificationTasksApiList
     */
    readonly resultUncertaintyMin?: number

    /**
     * 
     * @type {IdentificationtasksListReviewTypeParameter}
     * @memberof IdentificationTasksApiList
     */
    readonly reviewType?: IdentificationtasksListReviewTypeParameter

    /**
     * 
     * @type {Array<IdentificationtasksListStatusParameter>}
     * @memberof IdentificationTasksApiList
     */
    readonly status?: Array<IdentificationtasksListStatusParameter>

    /**
     * Update at
     * @type {string}
     * @memberof IdentificationTasksApiList
     */
    readonly updatedAtAfter?: string

    /**
     * Update at
     * @type {string}
     * @memberof IdentificationTasksApiList
     */
    readonly updatedAtBefore?: string
}

/**
 * Request parameters for listMine operation in IdentificationTasksApi.
 * @export
 * @interface IdentificationTasksApiListMineRequest
 */
export interface IdentificationTasksApiListMineRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof IdentificationTasksApiListMine
     */
    readonly annotatorIds?: Array<number>

    /**
     * 
     * @type {Array<number>}
     * @memberof IdentificationTasksApiListMine
     */
    readonly assigneeIds?: Array<number>

    /**
     * Created at
     * @type {string}
     * @memberof IdentificationTasksApiListMine
     */
    readonly createdAtAfter?: string

    /**
     * Created at
     * @type {string}
     * @memberof IdentificationTasksApiListMine
     */
    readonly createdAtBefore?: string

    /**
     * Filters identification task based on whether all associated photos have predictions. Set to True to include identification tasks where every photo has a prediction; set to False to include identification tasks where at least one photo is missing a prediction.
     * @type {boolean}
     * @memberof IdentificationTasksApiListMine
     */
    readonly fullyPredicted?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof IdentificationTasksApiListMine
     */
    readonly isFlagged?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof IdentificationTasksApiListMine
     */
    readonly isSafe?: boolean

    /**
     * 
     * @type {number}
     * @memberof IdentificationTasksApiListMine
     */
    readonly numAnnotationsMax?: number

    /**
     * 
     * @type {number}
     * @memberof IdentificationTasksApiListMine
     */
    readonly numAnnotationsMin?: number

    /**
     * 
     * @type {Array<number>}
     * @memberof IdentificationTasksApiListMine
     */
    readonly observationCountryIds?: Array<number>

    /**
     * Ordenado  
     * @type {Array<IdentificationtasksListOrderByParameter>}
     * @memberof IdentificationTasksApiListMine
     */
    readonly orderBy?: Array<IdentificationtasksListOrderByParameter>

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof IdentificationTasksApiListMine
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof IdentificationTasksApiListMine
     */
    readonly pageSize?: number

    /**
     * 
     * @type {number}
     * @memberof IdentificationTasksApiListMine
     */
    readonly resultAgreementMax?: number

    /**
     * 
     * @type {number}
     * @memberof IdentificationTasksApiListMine
     */
    readonly resultAgreementMin?: number

    /**
     * 
     * @type {string}
     * @memberof IdentificationTasksApiListMine
     */
    readonly resultConfidenceMax?: string

    /**
     * 
     * @type {string}
     * @memberof IdentificationTasksApiListMine
     */
    readonly resultConfidenceMin?: string

    /**
     * 
     * @type {IdentificationtasksListResultSourceParameter}
     * @memberof IdentificationTasksApiListMine
     */
    readonly resultSource?: IdentificationtasksListResultSourceParameter

    /**
     * 
     * @type {Array<number>}
     * @memberof IdentificationTasksApiListMine
     */
    readonly resultTaxonIds?: Array<number>

    /**
     * 
     * @type {number}
     * @memberof IdentificationTasksApiListMine
     */
    readonly resultUncertaintyMax?: number

    /**
     * 
     * @type {number}
     * @memberof IdentificationTasksApiListMine
     */
    readonly resultUncertaintyMin?: number

    /**
     * 
     * @type {IdentificationtasksListReviewTypeParameter}
     * @memberof IdentificationTasksApiListMine
     */
    readonly reviewType?: IdentificationtasksListReviewTypeParameter

    /**
     * 
     * @type {Array<IdentificationtasksListStatusParameter>}
     * @memberof IdentificationTasksApiListMine
     */
    readonly status?: Array<IdentificationtasksListStatusParameter>

    /**
     * Update at
     * @type {string}
     * @memberof IdentificationTasksApiListMine
     */
    readonly updatedAtAfter?: string

    /**
     * Update at
     * @type {string}
     * @memberof IdentificationTasksApiListMine
     */
    readonly updatedAtBefore?: string
}

/**
 * Request parameters for predictionsCreate operation in IdentificationTasksApi.
 * @export
 * @interface IdentificationTasksApiPredictionsCreateRequest
 */
export interface IdentificationTasksApiPredictionsCreateRequest {
    /**
     * UUID of the Observation
     * @type {string}
     * @memberof IdentificationTasksApiPredictionsCreate
     */
    readonly observationUuid: string

    /**
     * 
     * @type {CreatePhotoPredictionRequest}
     * @memberof IdentificationTasksApiPredictionsCreate
     */
    readonly createPhotoPredictionRequest: CreatePhotoPredictionRequest
}

/**
 * Request parameters for predictionsDestroy operation in IdentificationTasksApi.
 * @export
 * @interface IdentificationTasksApiPredictionsDestroyRequest
 */
export interface IdentificationTasksApiPredictionsDestroyRequest {
    /**
     * UUID of the Observation
     * @type {string}
     * @memberof IdentificationTasksApiPredictionsDestroy
     */
    readonly observationUuid: string

    /**
     * 
     * @type {string}
     * @memberof IdentificationTasksApiPredictionsDestroy
     */
    readonly photoUuid: string
}

/**
 * Request parameters for predictionsList operation in IdentificationTasksApi.
 * @export
 * @interface IdentificationTasksApiPredictionsListRequest
 */
export interface IdentificationTasksApiPredictionsListRequest {
    /**
     * UUID of the Observation
     * @type {string}
     * @memberof IdentificationTasksApiPredictionsList
     */
    readonly observationUuid: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof IdentificationTasksApiPredictionsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof IdentificationTasksApiPredictionsList
     */
    readonly pageSize?: number
}

/**
 * Request parameters for predictionsPartialUpdate operation in IdentificationTasksApi.
 * @export
 * @interface IdentificationTasksApiPredictionsPartialUpdateRequest
 */
export interface IdentificationTasksApiPredictionsPartialUpdateRequest {
    /**
     * UUID of the Observation
     * @type {string}
     * @memberof IdentificationTasksApiPredictionsPartialUpdate
     */
    readonly observationUuid: string

    /**
     * 
     * @type {string}
     * @memberof IdentificationTasksApiPredictionsPartialUpdate
     */
    readonly photoUuid: string

    /**
     * 
     * @type {PatchedPhotoPredictionRequest}
     * @memberof IdentificationTasksApiPredictionsPartialUpdate
     */
    readonly patchedPhotoPredictionRequest?: PatchedPhotoPredictionRequest
}

/**
 * Request parameters for predictionsRetrieve operation in IdentificationTasksApi.
 * @export
 * @interface IdentificationTasksApiPredictionsRetrieveRequest
 */
export interface IdentificationTasksApiPredictionsRetrieveRequest {
    /**
     * UUID of the Observation
     * @type {string}
     * @memberof IdentificationTasksApiPredictionsRetrieve
     */
    readonly observationUuid: string

    /**
     * 
     * @type {string}
     * @memberof IdentificationTasksApiPredictionsRetrieve
     */
    readonly photoUuid: string
}

/**
 * Request parameters for predictionsUpdate operation in IdentificationTasksApi.
 * @export
 * @interface IdentificationTasksApiPredictionsUpdateRequest
 */
export interface IdentificationTasksApiPredictionsUpdateRequest {
    /**
     * UUID of the Observation
     * @type {string}
     * @memberof IdentificationTasksApiPredictionsUpdate
     */
    readonly observationUuid: string

    /**
     * 
     * @type {string}
     * @memberof IdentificationTasksApiPredictionsUpdate
     */
    readonly photoUuid: string

    /**
     * 
     * @type {PhotoPredictionRequest}
     * @memberof IdentificationTasksApiPredictionsUpdate
     */
    readonly photoPredictionRequest: PhotoPredictionRequest
}

/**
 * Request parameters for retrieve operation in IdentificationTasksApi.
 * @export
 * @interface IdentificationTasksApiRetrieveRequest
 */
export interface IdentificationTasksApiRetrieveRequest {
    /**
     * 
     * @type {string}
     * @memberof IdentificationTasksApiRetrieve
     */
    readonly observationUuid: string
}

/**
 * IdentificationTasksApi - object-oriented interface
 * @export
 * @class IdentificationTasksApi
 * @extends {BaseAPI}
 */
export class IdentificationTasksApi extends BaseAPI {
    /**
     * 
     * @param {IdentificationTasksApiAnnotationsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentificationTasksApi
     */
    public annotationsCreate(requestParameters: IdentificationTasksApiAnnotationsCreateRequest, options?: RawAxiosRequestConfig) {
        return IdentificationTasksApiFp(this.configuration).annotationsCreate(requestParameters.observationUuid, requestParameters.annotationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IdentificationTasksApiAnnotationsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentificationTasksApi
     */
    public annotationsList(requestParameters: IdentificationTasksApiAnnotationsListRequest, options?: RawAxiosRequestConfig) {
        return IdentificationTasksApiFp(this.configuration).annotationsList(requestParameters.observationUuid, requestParameters.classificationConfidenceLabel, requestParameters.classificationConfidenceMax, requestParameters.classificationConfidenceMin, requestParameters.classificationTaxonIds, requestParameters.createdAtAfter, requestParameters.createdAtBefore, requestParameters.isDecisive, requestParameters.isFavourite, requestParameters.isFlagged, requestParameters.orderBy, requestParameters.page, requestParameters.pageSize, requestParameters.type, requestParameters.updatedAtAfter, requestParameters.updatedAtBefore, requestParameters.userIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get my annotations
     * @param {IdentificationTasksApiAnnotationsListMineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentificationTasksApi
     */
    public annotationsListMine(requestParameters: IdentificationTasksApiAnnotationsListMineRequest = {}, options?: RawAxiosRequestConfig) {
        return IdentificationTasksApiFp(this.configuration).annotationsListMine(requestParameters.classificationConfidenceLabel, requestParameters.classificationConfidenceMax, requestParameters.classificationConfidenceMin, requestParameters.classificationTaxonIds, requestParameters.createdAtAfter, requestParameters.createdAtBefore, requestParameters.isDecisive, requestParameters.isFavourite, requestParameters.isFlagged, requestParameters.orderBy, requestParameters.page, requestParameters.pageSize, requestParameters.type, requestParameters.updatedAtAfter, requestParameters.updatedAtBefore, requestParameters.userIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IdentificationTasksApiAnnotationsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentificationTasksApi
     */
    public annotationsRetrieve(requestParameters: IdentificationTasksApiAnnotationsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return IdentificationTasksApiFp(this.configuration).annotationsRetrieve(requestParameters.id, requestParameters.observationUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assign the next available identification task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentificationTasksApi
     */
    public assignNext(options?: RawAxiosRequestConfig) {
        return IdentificationTasksApiFp(this.configuration).assignNext(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IdentificationTasksApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentificationTasksApi
     */
    public list(requestParameters: IdentificationTasksApiListRequest = {}, options?: RawAxiosRequestConfig) {
        return IdentificationTasksApiFp(this.configuration).list(requestParameters.annotatorIds, requestParameters.assigneeIds, requestParameters.createdAtAfter, requestParameters.createdAtBefore, requestParameters.fullyPredicted, requestParameters.isFlagged, requestParameters.isSafe, requestParameters.numAnnotationsMax, requestParameters.numAnnotationsMin, requestParameters.observationCountryIds, requestParameters.orderBy, requestParameters.page, requestParameters.pageSize, requestParameters.resultAgreementMax, requestParameters.resultAgreementMin, requestParameters.resultConfidenceMax, requestParameters.resultConfidenceMin, requestParameters.resultSource, requestParameters.resultTaxonIds, requestParameters.resultUncertaintyMax, requestParameters.resultUncertaintyMin, requestParameters.reviewType, requestParameters.status, requestParameters.updatedAtAfter, requestParameters.updatedAtBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get identification tasks annotated by me
     * @param {IdentificationTasksApiListMineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentificationTasksApi
     */
    public listMine(requestParameters: IdentificationTasksApiListMineRequest = {}, options?: RawAxiosRequestConfig) {
        return IdentificationTasksApiFp(this.configuration).listMine(requestParameters.annotatorIds, requestParameters.assigneeIds, requestParameters.createdAtAfter, requestParameters.createdAtBefore, requestParameters.fullyPredicted, requestParameters.isFlagged, requestParameters.isSafe, requestParameters.numAnnotationsMax, requestParameters.numAnnotationsMin, requestParameters.observationCountryIds, requestParameters.orderBy, requestParameters.page, requestParameters.pageSize, requestParameters.resultAgreementMax, requestParameters.resultAgreementMin, requestParameters.resultConfidenceMax, requestParameters.resultConfidenceMin, requestParameters.resultSource, requestParameters.resultTaxonIds, requestParameters.resultUncertaintyMax, requestParameters.resultUncertaintyMin, requestParameters.reviewType, requestParameters.status, requestParameters.updatedAtAfter, requestParameters.updatedAtBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IdentificationTasksApiPredictionsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentificationTasksApi
     */
    public predictionsCreate(requestParameters: IdentificationTasksApiPredictionsCreateRequest, options?: RawAxiosRequestConfig) {
        return IdentificationTasksApiFp(this.configuration).predictionsCreate(requestParameters.observationUuid, requestParameters.createPhotoPredictionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IdentificationTasksApiPredictionsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentificationTasksApi
     */
    public predictionsDestroy(requestParameters: IdentificationTasksApiPredictionsDestroyRequest, options?: RawAxiosRequestConfig) {
        return IdentificationTasksApiFp(this.configuration).predictionsDestroy(requestParameters.observationUuid, requestParameters.photoUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IdentificationTasksApiPredictionsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentificationTasksApi
     */
    public predictionsList(requestParameters: IdentificationTasksApiPredictionsListRequest, options?: RawAxiosRequestConfig) {
        return IdentificationTasksApiFp(this.configuration).predictionsList(requestParameters.observationUuid, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IdentificationTasksApiPredictionsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentificationTasksApi
     */
    public predictionsPartialUpdate(requestParameters: IdentificationTasksApiPredictionsPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return IdentificationTasksApiFp(this.configuration).predictionsPartialUpdate(requestParameters.observationUuid, requestParameters.photoUuid, requestParameters.patchedPhotoPredictionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IdentificationTasksApiPredictionsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentificationTasksApi
     */
    public predictionsRetrieve(requestParameters: IdentificationTasksApiPredictionsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return IdentificationTasksApiFp(this.configuration).predictionsRetrieve(requestParameters.observationUuid, requestParameters.photoUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IdentificationTasksApiPredictionsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentificationTasksApi
     */
    public predictionsUpdate(requestParameters: IdentificationTasksApiPredictionsUpdateRequest, options?: RawAxiosRequestConfig) {
        return IdentificationTasksApiFp(this.configuration).predictionsUpdate(requestParameters.observationUuid, requestParameters.photoUuid, requestParameters.photoPredictionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IdentificationTasksApiRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentificationTasksApi
     */
    public retrieve(requestParameters: IdentificationTasksApiRetrieveRequest, options?: RawAxiosRequestConfig) {
        return IdentificationTasksApiFp(this.configuration).retrieve(requestParameters.observationUuid, options).then((request) => request(this.axios, this.basePath));
    }
}

