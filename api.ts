/* tslint:disable */
/* eslint-disable */
/**
 * Mosquito Alert API
 * Introducing API v1 for Mosquito Alert platform, a project desgined to facilitate citizen science initiatives and enable collaboration among scientists, public health officials, and environmental managers in the investigation and control of disease-carrying mosquitoes.
 *
 * The version of the OpenAPI document: v1
 * Contact: it@mosquitoalert.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AppUserTokenObtainPair
 */
export interface AppUserTokenObtainPair {
    /**
     * 
     * @type {string}
     * @memberof AppUserTokenObtainPair
     */
    'access': string;
    /**
     * 
     * @type {string}
     * @memberof AppUserTokenObtainPair
     */
    'refresh': string;
}
/**
 * 
 * @export
 * @interface AppUserTokenObtainPairRequest
 */
export interface AppUserTokenObtainPairRequest {
    /**
     * 
     * @type {string}
     * @memberof AppUserTokenObtainPairRequest
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof AppUserTokenObtainPairRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof AppUserTokenObtainPairRequest
     */
    'device_id'?: string;
}
/**
 * 
 * @export
 * @interface Bite
 */
export interface Bite {
    /**
     * 
     * @type {string}
     * @memberof Bite
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof Bite
     */
    'short_id': string;
    /**
     * 
     * @type {string}
     * @memberof Bite
     */
    'user_uuid': string;
    /**
     * 
     * @type {string}
     * @memberof Bite
     */
    'created_at': string;
    /**
     * The date and time when the record was created, displayed in the local timezone specified for this entry.
     * @type {string}
     * @memberof Bite
     */
    'created_at_local': string;
    /**
     * 
     * @type {string}
     * @memberof Bite
     */
    'sent_at': string;
    /**
     * 
     * @type {string}
     * @memberof Bite
     */
    'received_at': string;
    /**
     * Date and time when the report was last modified
     * @type {string}
     * @memberof Bite
     */
    'updated_at': string;
    /**
     * 
     * @type {Location}
     * @memberof Bite
     */
    'location': Location;
    /**
     * Note user attached to report.
     * @type {string}
     * @memberof Bite
     */
    'note'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Bite
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Bite
     */
    'published': boolean;
    /**
     * The environment where the event took place.
     * @type {string}
     * @memberof Bite
     */
    'event_environment'?: BiteEventEnvironmentEnum | null;
    /**
     * The moment of the day when the event took place.
     * @type {string}
     * @memberof Bite
     */
    'event_moment'?: BiteEventMomentEnum | null;
    /**
     * Total number of bites reported.
     * @type {number}
     * @memberof Bite
     */
    'bite_count': number;
    /**
     * Number of bites reported in the head.
     * @type {number}
     * @memberof Bite
     */
    'head_bite_count'?: number | null;
    /**
     * Number of bites reported in the left arm.
     * @type {number}
     * @memberof Bite
     */
    'left_arm_bite_count'?: number | null;
    /**
     * Number of bites reported in the right arm.
     * @type {number}
     * @memberof Bite
     */
    'right_arm_bite_count'?: number | null;
    /**
     * Number of bites reported in the chest.
     * @type {number}
     * @memberof Bite
     */
    'chest_bite_count'?: number | null;
    /**
     * Number of bites reported in the left leg.
     * @type {number}
     * @memberof Bite
     */
    'left_leg_bite_count'?: number | null;
    /**
     * Number of bites reported in the right leg.
     * @type {number}
     * @memberof Bite
     */
    'right_leg_bite_count'?: number | null;
}

export const BiteEventEnvironmentEnum = {
    Indoors: 'indoors',
    Outdoors: 'outdoors',
    Vehicle: 'vehicle',
    Empty: ''
} as const;

export type BiteEventEnvironmentEnum = typeof BiteEventEnvironmentEnum[keyof typeof BiteEventEnvironmentEnum];
export const BiteEventMomentEnum = {
    Now: 'now',
    LastMorning: 'last_morning',
    LastMidday: 'last_midday',
    LastAfternoon: 'last_afternoon',
    LastNight: 'last_night',
    Empty: ''
} as const;

export type BiteEventMomentEnum = typeof BiteEventMomentEnum[keyof typeof BiteEventMomentEnum];

/**
 * 
 * @export
 * @interface BiteRequest
 */
export interface BiteRequest {
    /**
     * 
     * @type {string}
     * @memberof BiteRequest
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof BiteRequest
     */
    'sent_at': string;
    /**
     * 
     * @type {LocationRequest}
     * @memberof BiteRequest
     */
    'location': LocationRequest;
    /**
     * Note user attached to report.
     * @type {string}
     * @memberof BiteRequest
     */
    'note'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof BiteRequest
     */
    'tags'?: Array<string>;
    /**
     * The environment where the event took place.
     * @type {string}
     * @memberof BiteRequest
     */
    'event_environment'?: BiteRequestEventEnvironmentEnum | null;
    /**
     * The moment of the day when the event took place.
     * @type {string}
     * @memberof BiteRequest
     */
    'event_moment'?: BiteRequestEventMomentEnum | null;
    /**
     * Number of bites reported in the head.
     * @type {number}
     * @memberof BiteRequest
     */
    'head_bite_count'?: number | null;
    /**
     * Number of bites reported in the left arm.
     * @type {number}
     * @memberof BiteRequest
     */
    'left_arm_bite_count'?: number | null;
    /**
     * Number of bites reported in the right arm.
     * @type {number}
     * @memberof BiteRequest
     */
    'right_arm_bite_count'?: number | null;
    /**
     * Number of bites reported in the chest.
     * @type {number}
     * @memberof BiteRequest
     */
    'chest_bite_count'?: number | null;
    /**
     * Number of bites reported in the left leg.
     * @type {number}
     * @memberof BiteRequest
     */
    'left_leg_bite_count'?: number | null;
    /**
     * Number of bites reported in the right leg.
     * @type {number}
     * @memberof BiteRequest
     */
    'right_leg_bite_count'?: number | null;
}

export const BiteRequestEventEnvironmentEnum = {
    Indoors: 'indoors',
    Outdoors: 'outdoors',
    Vehicle: 'vehicle',
    Empty: ''
} as const;

export type BiteRequestEventEnvironmentEnum = typeof BiteRequestEventEnvironmentEnum[keyof typeof BiteRequestEventEnvironmentEnum];
export const BiteRequestEventMomentEnum = {
    Now: 'now',
    LastMorning: 'last_morning',
    LastMidday: 'last_midday',
    LastAfternoon: 'last_afternoon',
    LastNight: 'last_night',
    Empty: ''
} as const;

export type BiteRequestEventMomentEnum = typeof BiteRequestEventMomentEnum[keyof typeof BiteRequestEventMomentEnum];

/**
 * 
 * @export
 * @interface BoundingBox
 */
export interface BoundingBox {
    /**
     * photo bounding box coordinates top left x
     * @type {number}
     * @memberof BoundingBox
     */
    'x_min': number;
    /**
     * photo bounding box coordinates top left y
     * @type {number}
     * @memberof BoundingBox
     */
    'y_min': number;
    /**
     * photo bounding box coordinates bottom right x
     * @type {number}
     * @memberof BoundingBox
     */
    'x_max': number;
    /**
     * photo bounding box coordinates bottom right y
     * @type {number}
     * @memberof BoundingBox
     */
    'y_max': number;
}
/**
 * 
 * @export
 * @interface BoundingBoxRequest
 */
export interface BoundingBoxRequest {
    /**
     * photo bounding box coordinates top left x
     * @type {number}
     * @memberof BoundingBoxRequest
     */
    'x_min': number;
    /**
     * photo bounding box coordinates top left y
     * @type {number}
     * @memberof BoundingBoxRequest
     */
    'y_min': number;
    /**
     * photo bounding box coordinates bottom right x
     * @type {number}
     * @memberof BoundingBoxRequest
     */
    'x_max': number;
    /**
     * photo bounding box coordinates bottom right y
     * @type {number}
     * @memberof BoundingBoxRequest
     */
    'y_max': number;
}
/**
 * 
 * @export
 * @interface BreedingSite
 */
export interface BreedingSite {
    /**
     * 
     * @type {string}
     * @memberof BreedingSite
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof BreedingSite
     */
    'short_id': string;
    /**
     * 
     * @type {string}
     * @memberof BreedingSite
     */
    'user_uuid': string;
    /**
     * 
     * @type {string}
     * @memberof BreedingSite
     */
    'created_at': string;
    /**
     * The date and time when the record was created, displayed in the local timezone specified for this entry.
     * @type {string}
     * @memberof BreedingSite
     */
    'created_at_local': string;
    /**
     * 
     * @type {string}
     * @memberof BreedingSite
     */
    'sent_at': string;
    /**
     * 
     * @type {string}
     * @memberof BreedingSite
     */
    'received_at': string;
    /**
     * Date and time when the report was last modified
     * @type {string}
     * @memberof BreedingSite
     */
    'updated_at': string;
    /**
     * 
     * @type {Location}
     * @memberof BreedingSite
     */
    'location': Location;
    /**
     * Note user attached to report.
     * @type {string}
     * @memberof BreedingSite
     */
    'note'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof BreedingSite
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof BreedingSite
     */
    'published': boolean;
    /**
     * 
     * @type {Array<SimplePhoto>}
     * @memberof BreedingSite
     */
    'photos': Array<SimplePhoto>;
    /**
     * Breeding site type.
     * @type {string}
     * @memberof BreedingSite
     */
    'site_type'?: BreedingSiteSiteTypeEnum;
    /**
     * Either if the user perceived water in the breeding site.
     * @type {boolean}
     * @memberof BreedingSite
     */
    'has_water'?: boolean | null;
    /**
     * Either if the breeding site is found in a public area.
     * @type {boolean}
     * @memberof BreedingSite
     */
    'in_public_area'?: boolean | null;
    /**
     * Either if the user perceived mosquitoes near the breeding site (less than 10 meters).
     * @type {boolean}
     * @memberof BreedingSite
     */
    'has_near_mosquitoes'?: boolean | null;
    /**
     * Either if the user perceived larvaes the breeding site.
     * @type {boolean}
     * @memberof BreedingSite
     */
    'has_larvae'?: boolean | null;
}

export const BreedingSiteSiteTypeEnum = {
    Basin: 'basin',
    Bucket: 'bucket',
    Fountain: 'fountain',
    SmallContainer: 'small_container',
    StormDrain: 'storm_drain',
    Well: 'well',
    Other: 'other',
    Empty: ''
} as const;

export type BreedingSiteSiteTypeEnum = typeof BreedingSiteSiteTypeEnum[keyof typeof BreedingSiteSiteTypeEnum];

/**
 * 
 * @export
 * @interface BreedingSiteRequest
 */
export interface BreedingSiteRequest {
    /**
     * 
     * @type {string}
     * @memberof BreedingSiteRequest
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof BreedingSiteRequest
     */
    'sent_at': string;
    /**
     * 
     * @type {LocationRequest}
     * @memberof BreedingSiteRequest
     */
    'location': LocationRequest;
    /**
     * Note user attached to report.
     * @type {string}
     * @memberof BreedingSiteRequest
     */
    'note'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof BreedingSiteRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<SimplePhotoRequest>}
     * @memberof BreedingSiteRequest
     */
    'photos': Array<SimplePhotoRequest>;
    /**
     * Breeding site type.
     * @type {string}
     * @memberof BreedingSiteRequest
     */
    'site_type'?: BreedingSiteRequestSiteTypeEnum;
    /**
     * Either if the user perceived water in the breeding site.
     * @type {boolean}
     * @memberof BreedingSiteRequest
     */
    'has_water'?: boolean | null;
    /**
     * Either if the breeding site is found in a public area.
     * @type {boolean}
     * @memberof BreedingSiteRequest
     */
    'in_public_area'?: boolean | null;
    /**
     * Either if the user perceived mosquitoes near the breeding site (less than 10 meters).
     * @type {boolean}
     * @memberof BreedingSiteRequest
     */
    'has_near_mosquitoes'?: boolean | null;
    /**
     * Either if the user perceived larvaes the breeding site.
     * @type {boolean}
     * @memberof BreedingSiteRequest
     */
    'has_larvae'?: boolean | null;
}

export const BreedingSiteRequestSiteTypeEnum = {
    Basin: 'basin',
    Bucket: 'bucket',
    Fountain: 'fountain',
    SmallContainer: 'small_container',
    StormDrain: 'storm_drain',
    Well: 'well',
    Other: 'other',
    Empty: ''
} as const;

export type BreedingSiteRequestSiteTypeEnum = typeof BreedingSiteRequestSiteTypeEnum[keyof typeof BreedingSiteRequestSiteTypeEnum];

/**
 * 
 * @export
 * @interface Campaign
 */
export interface Campaign {
    /**
     * 
     * @type {number}
     * @memberof Campaign
     */
    'id': number;
    /**
     * Country in which the campaign is taking place
     * @type {number}
     * @memberof Campaign
     */
    'country_id': number;
    /**
     * Full posting address of the place where the samples will be sent
     * @type {string}
     * @memberof Campaign
     */
    'posting_address': string;
    /**
     * Date when the campaign starts. No samples should be collected BEFORE this date.
     * @type {string}
     * @memberof Campaign
     */
    'start_date': string;
    /**
     * Date when the campaign ends. No samples should be collected AFTER this date.
     * @type {string}
     * @memberof Campaign
     */
    'end_date': string;
}
/**
 * 
 * @export
 * @interface Country
 */
export interface Country {
    /**
     * 
     * @type {number}
     * @memberof Country
     */
    'id': number;
    /**
     * Full name of the country in English (e.g., Spain).
     * @type {string}
     * @memberof Country
     */
    'name_en': string;
    /**
     * ISO 3166-1 alpha-3 country code (3-letter code, e.g., ESP).
     * @type {string}
     * @memberof Country
     */
    'iso3_code': string;
}
/**
 * 
 * @export
 * @interface CreateNotification
 */
export interface CreateNotification {
    /**
     * 
     * @type {number}
     * @memberof CreateNotification
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CreateNotification
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface CreateNotificationMessage
 */
export interface CreateNotificationMessage {
    /**
     * Provide the message\'s title in all supported languages
     * @type {LocalizedField}
     * @memberof CreateNotificationMessage
     */
    'title': LocalizedField;
    /**
     * Provide the message\'s body in all supported languages
     * @type {LocalizedField}
     * @memberof CreateNotificationMessage
     */
    'body': LocalizedField;
}
/**
 * 
 * @export
 * @interface CreateNotificationMessageRequest
 */
export interface CreateNotificationMessageRequest {
    /**
     * Provide the message\'s title in all supported languages
     * @type {LocalizedFieldRequest}
     * @memberof CreateNotificationMessageRequest
     */
    'title': LocalizedFieldRequest;
    /**
     * Provide the message\'s body in all supported languages
     * @type {LocalizedFieldRequest}
     * @memberof CreateNotificationMessageRequest
     */
    'body': LocalizedFieldRequest;
}
/**
 * 
 * @export
 * @interface CreateUser
 */
export interface CreateUser {
    /**
     * 
     * @type {string}
     * @memberof CreateUser
     */
    'uuid': string;
    /**
     * The date and time when user registered and consented to sharing data. Automatically set by server when user uploads registration.
     * @type {string}
     * @memberof CreateUser
     */
    'registration_time': string;
    /**
     * The locale code representing the language preference selected by the user for displaying the interface text. Enter the locale following the BCP 47 standard in \'language\' or \'language-region\' format (e.g., \'en\' for English, \'en-US\' for English (United States), \'fr\' for French). The language is a two-letter ISO 639-1 code, and the region is an optional two-letter ISO 3166-1 alpha-2 code.
     * @type {string}
     * @memberof CreateUser
     */
    'locale'?: CreateUserLocaleEnum;
    /**
     * ISO 639-1 code
     * @type {string}
     * @memberof CreateUser
     */
    'language_iso': string;
    /**
     * Global XP Score. This field is updated whenever the user asks for the score, and is only stored here. The content must equal score_v2_adult + score_v2_bite + score_v2_site
     * @type {number}
     * @memberof CreateUser
     */
    'score': number;
    /**
     * Last time score was updated
     * @type {string}
     * @memberof CreateUser
     */
    'last_score_update': string;
}

export const CreateUserLocaleEnum = {
    Es: 'es',
    Ca: 'ca',
    Eu: 'eu',
    Bn: 'bn',
    Sv: 'sv',
    En: 'en',
    De: 'de',
    Sq: 'sq',
    El: 'el',
    Gl: 'gl',
    Hu: 'hu',
    Pt: 'pt',
    Sl: 'sl',
    It: 'it',
    Fr: 'fr',
    Bg: 'bg',
    Ro: 'ro',
    Hr: 'hr',
    Mk: 'mk',
    Sr: 'sr',
    Lb: 'lb',
    Nl: 'nl',
    Tr: 'tr',
    ZhCn: 'zh-CN'
} as const;

export type CreateUserLocaleEnum = typeof CreateUserLocaleEnum[keyof typeof CreateUserLocaleEnum];

/**
 * 
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     * The locale code representing the language preference selected by the user for displaying the interface text. Enter the locale following the BCP 47 standard in \'language\' or \'language-region\' format (e.g., \'en\' for English, \'en-US\' for English (United States), \'fr\' for French). The language is a two-letter ISO 639-1 code, and the region is an optional two-letter ISO 3166-1 alpha-2 code.
     * @type {string}
     * @memberof CreateUserRequest
     */
    'locale'?: CreateUserRequestLocaleEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'password': string;
}

export const CreateUserRequestLocaleEnum = {
    Es: 'es',
    Ca: 'ca',
    Eu: 'eu',
    Bn: 'bn',
    Sv: 'sv',
    En: 'en',
    De: 'de',
    Sq: 'sq',
    El: 'el',
    Gl: 'gl',
    Hu: 'hu',
    Pt: 'pt',
    Sl: 'sl',
    It: 'it',
    Fr: 'fr',
    Bg: 'bg',
    Ro: 'ro',
    Hr: 'hr',
    Mk: 'mk',
    Sr: 'sr',
    Lb: 'lb',
    Nl: 'nl',
    Tr: 'tr',
    ZhCn: 'zh-CN'
} as const;

export type CreateUserRequestLocaleEnum = typeof CreateUserRequestLocaleEnum[keyof typeof CreateUserRequestLocaleEnum];

/**
 * 
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * Unique device identifier
     * @type {string}
     * @memberof Device
     */
    'device_id': string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'type': DeviceTypeEnum;
    /**
     * The manufacturer of the device.
     * @type {string}
     * @memberof Device
     */
    'manufacturer'?: string | null;
    /**
     * The end-user-visible name for the end product.
     * @type {string}
     * @memberof Device
     */
    'model': string;
    /**
     * 
     * @type {DeviceOs}
     * @memberof Device
     */
    'os': DeviceOs;
    /**
     * 
     * @type {MobileApp}
     * @memberof Device
     */
    'mobile_app'?: MobileApp;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'user_uuid': string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'last_login': string | null;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'updated_at': string;
}

export const DeviceTypeEnum = {
    Ios: 'ios',
    Android: 'android',
    Web: 'web'
} as const;

export type DeviceTypeEnum = typeof DeviceTypeEnum[keyof typeof DeviceTypeEnum];

/**
 * 
 * @export
 * @interface DeviceOs
 */
export interface DeviceOs {
    /**
     * Operating system of device from which this report was submitted.
     * @type {string}
     * @memberof DeviceOs
     */
    'name': string;
    /**
     * Operating system version of device from which this report was submitted.
     * @type {string}
     * @memberof DeviceOs
     */
    'version': string;
    /**
     * The locale configured in the device following the BCP 47 standard in \'language\' or \'language-region\' format (e.g., \'en\' for English, \'en-US\' for English (United States), \'fr\' for French). The language is a two-letter ISO 639-1 code, and the region is an optional two-letter ISO 3166-1 alpha-2 code.
     * @type {string}
     * @memberof DeviceOs
     */
    'locale'?: string | null;
}
/**
 * 
 * @export
 * @interface DeviceOsRequest
 */
export interface DeviceOsRequest {
    /**
     * Operating system of device from which this report was submitted.
     * @type {string}
     * @memberof DeviceOsRequest
     */
    'name': string;
    /**
     * Operating system version of device from which this report was submitted.
     * @type {string}
     * @memberof DeviceOsRequest
     */
    'version': string;
    /**
     * The locale configured in the device following the BCP 47 standard in \'language\' or \'language-region\' format (e.g., \'en\' for English, \'en-US\' for English (United States), \'fr\' for French). The language is a two-letter ISO 639-1 code, and the region is an optional two-letter ISO 3166-1 alpha-2 code.
     * @type {string}
     * @memberof DeviceOsRequest
     */
    'locale'?: string | null;
}
/**
 * 
 * @export
 * @interface DeviceRequest
 */
export interface DeviceRequest {
    /**
     * Unique device identifier
     * @type {string}
     * @memberof DeviceRequest
     */
    'device_id': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceRequest
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceRequest
     */
    'fcm_token': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceRequest
     */
    'type': DeviceRequestTypeEnum;
    /**
     * The manufacturer of the device.
     * @type {string}
     * @memberof DeviceRequest
     */
    'manufacturer'?: string | null;
    /**
     * The end-user-visible name for the end product.
     * @type {string}
     * @memberof DeviceRequest
     */
    'model': string;
    /**
     * 
     * @type {DeviceOsRequest}
     * @memberof DeviceRequest
     */
    'os': DeviceOsRequest;
    /**
     * 
     * @type {MobileAppRequest}
     * @memberof DeviceRequest
     */
    'mobile_app'?: MobileAppRequest;
}

export const DeviceRequestTypeEnum = {
    Ios: 'ios',
    Android: 'android',
    Web: 'web'
} as const;

export type DeviceRequestTypeEnum = typeof DeviceRequestTypeEnum[keyof typeof DeviceRequestTypeEnum];

/**
 * 
 * @export
 * @interface DeviceUpdate
 */
export interface DeviceUpdate {
    /**
     * Unique device identifier
     * @type {string}
     * @memberof DeviceUpdate
     */
    'device_id': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceUpdate
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceUpdate
     */
    'type': DeviceUpdateTypeEnum;
    /**
     * The manufacturer of the device.
     * @type {string}
     * @memberof DeviceUpdate
     */
    'manufacturer': string;
    /**
     * The end-user-visible name for the end product.
     * @type {string}
     * @memberof DeviceUpdate
     */
    'model': string;
    /**
     * 
     * @type {DeviceOs}
     * @memberof DeviceUpdate
     */
    'os': DeviceOs;
    /**
     * 
     * @type {MobileApp}
     * @memberof DeviceUpdate
     */
    'mobile_app'?: MobileApp;
    /**
     * 
     * @type {string}
     * @memberof DeviceUpdate
     */
    'user_uuid': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceUpdate
     */
    'last_login': string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceUpdate
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceUpdate
     */
    'updated_at': string;
}

export const DeviceUpdateTypeEnum = {
    Ios: 'ios',
    Android: 'android',
    Web: 'web'
} as const;

export type DeviceUpdateTypeEnum = typeof DeviceUpdateTypeEnum[keyof typeof DeviceUpdateTypeEnum];

/**
 * 
 * @export
 * @interface DeviceUpdateRequest
 */
export interface DeviceUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof DeviceUpdateRequest
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceUpdateRequest
     */
    'fcm_token': string;
    /**
     * 
     * @type {DeviceOsRequest}
     * @memberof DeviceUpdateRequest
     */
    'os': DeviceOsRequest;
    /**
     * 
     * @type {MobileAppRequest}
     * @memberof DeviceUpdateRequest
     */
    'mobile_app'?: MobileAppRequest;
}
/**
 * 
 * @export
 * @interface Fix
 */
export interface Fix {
    /**
     * 
     * @type {string}
     * @memberof Fix
     */
    'coverage_uuid': string;
    /**
     * 
     * @type {string}
     * @memberof Fix
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Fix
     */
    'sent_at': string;
    /**
     * Date and time registered by server when it received fix upload. Automatically generated by server.
     * @type {string}
     * @memberof Fix
     */
    'received_at': string;
    /**
     * 
     * @type {FixLocation}
     * @memberof Fix
     */
    'point': FixLocation;
    /**
     * Power level of phone at time fix recorded, expressed as proportion of full charge. Range: 0-1.
     * @type {number}
     * @memberof Fix
     */
    'power'?: number | null;
}
/**
 * 
 * @export
 * @interface FixLocation
 */
export interface FixLocation {
    /**
     * Latitude rounded down to nearest 0.025 decimal degree.
     * @type {number}
     * @memberof FixLocation
     */
    'latitude': number;
    /**
     * Longitude rounded down to nearest 0.025 decimal degree.
     * @type {number}
     * @memberof FixLocation
     */
    'longitude': number;
}
/**
 * 
 * @export
 * @interface FixLocationRequest
 */
export interface FixLocationRequest {
    /**
     * Latitude rounded down to nearest 0.025 decimal degree.
     * @type {number}
     * @memberof FixLocationRequest
     */
    'latitude': number;
    /**
     * Longitude rounded down to nearest 0.025 decimal degree.
     * @type {number}
     * @memberof FixLocationRequest
     */
    'longitude': number;
}
/**
 * 
 * @export
 * @interface FixRequest
 */
export interface FixRequest {
    /**
     * 
     * @type {string}
     * @memberof FixRequest
     */
    'coverage_uuid': string;
    /**
     * 
     * @type {string}
     * @memberof FixRequest
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof FixRequest
     */
    'sent_at': string;
    /**
     * 
     * @type {FixLocationRequest}
     * @memberof FixRequest
     */
    'point': FixLocationRequest;
    /**
     * Power level of phone at time fix recorded, expressed as proportion of full charge. Range: 0-1.
     * @type {number}
     * @memberof FixRequest
     */
    'power'?: number | null;
}
/**
 * A custom serializer field that supports localization for a dynamic field name. Allows calling with arguments such as \'title\', \'message\', max_length, help_text, etc.
 * @export
 * @interface LocalizedField
 */
export interface LocalizedField {
    /**
     * Български
     * @type {string}
     * @memberof LocalizedField
     */
    'bg'?: string;
    /**
     * বাংলা
     * @type {string}
     * @memberof LocalizedField
     */
    'bn'?: string;
    /**
     * Català
     * @type {string}
     * @memberof LocalizedField
     */
    'ca'?: string;
    /**
     * Deutsch
     * @type {string}
     * @memberof LocalizedField
     */
    'de'?: string;
    /**
     * Ελληνικά
     * @type {string}
     * @memberof LocalizedField
     */
    'el'?: string;
    /**
     * English
     * @type {string}
     * @memberof LocalizedField
     */
    'en': string;
    /**
     * Español
     * @type {string}
     * @memberof LocalizedField
     */
    'es'?: string;
    /**
     * Euskara
     * @type {string}
     * @memberof LocalizedField
     */
    'eu'?: string;
    /**
     * Français
     * @type {string}
     * @memberof LocalizedField
     */
    'fr'?: string;
    /**
     * Galego
     * @type {string}
     * @memberof LocalizedField
     */
    'gl'?: string;
    /**
     * Hrvatski
     * @type {string}
     * @memberof LocalizedField
     */
    'hr'?: string;
    /**
     * Magyar
     * @type {string}
     * @memberof LocalizedField
     */
    'hu'?: string;
    /**
     * Italiano
     * @type {string}
     * @memberof LocalizedField
     */
    'it'?: string;
    /**
     * Lëtzebuergesch
     * @type {string}
     * @memberof LocalizedField
     */
    'lb'?: string;
    /**
     * Македонски
     * @type {string}
     * @memberof LocalizedField
     */
    'mk'?: string;
    /**
     * Nederlands
     * @type {string}
     * @memberof LocalizedField
     */
    'nl'?: string;
    /**
     * Português
     * @type {string}
     * @memberof LocalizedField
     */
    'pt'?: string;
    /**
     * Română
     * @type {string}
     * @memberof LocalizedField
     */
    'ro'?: string;
    /**
     * Slovenščina
     * @type {string}
     * @memberof LocalizedField
     */
    'sl'?: string;
    /**
     * Shqip
     * @type {string}
     * @memberof LocalizedField
     */
    'sq'?: string;
    /**
     * Српски
     * @type {string}
     * @memberof LocalizedField
     */
    'sr'?: string;
    /**
     * Svenska
     * @type {string}
     * @memberof LocalizedField
     */
    'sv'?: string;
    /**
     * Türkçe
     * @type {string}
     * @memberof LocalizedField
     */
    'tr'?: string;
    /**
     * 中文（中国）
     * @type {string}
     * @memberof LocalizedField
     */
    'zh-CN'?: string;
}
/**
 * A custom serializer field that supports localization for a dynamic field name. Allows calling with arguments such as \'title\', \'message\', max_length, help_text, etc.
 * @export
 * @interface LocalizedFieldRequest
 */
export interface LocalizedFieldRequest {
    /**
     * Български
     * @type {string}
     * @memberof LocalizedFieldRequest
     */
    'bg'?: string;
    /**
     * বাংলা
     * @type {string}
     * @memberof LocalizedFieldRequest
     */
    'bn'?: string;
    /**
     * Català
     * @type {string}
     * @memberof LocalizedFieldRequest
     */
    'ca'?: string;
    /**
     * Deutsch
     * @type {string}
     * @memberof LocalizedFieldRequest
     */
    'de'?: string;
    /**
     * Ελληνικά
     * @type {string}
     * @memberof LocalizedFieldRequest
     */
    'el'?: string;
    /**
     * English
     * @type {string}
     * @memberof LocalizedFieldRequest
     */
    'en': string;
    /**
     * Español
     * @type {string}
     * @memberof LocalizedFieldRequest
     */
    'es'?: string;
    /**
     * Euskara
     * @type {string}
     * @memberof LocalizedFieldRequest
     */
    'eu'?: string;
    /**
     * Français
     * @type {string}
     * @memberof LocalizedFieldRequest
     */
    'fr'?: string;
    /**
     * Galego
     * @type {string}
     * @memberof LocalizedFieldRequest
     */
    'gl'?: string;
    /**
     * Hrvatski
     * @type {string}
     * @memberof LocalizedFieldRequest
     */
    'hr'?: string;
    /**
     * Magyar
     * @type {string}
     * @memberof LocalizedFieldRequest
     */
    'hu'?: string;
    /**
     * Italiano
     * @type {string}
     * @memberof LocalizedFieldRequest
     */
    'it'?: string;
    /**
     * Lëtzebuergesch
     * @type {string}
     * @memberof LocalizedFieldRequest
     */
    'lb'?: string;
    /**
     * Македонски
     * @type {string}
     * @memberof LocalizedFieldRequest
     */
    'mk'?: string;
    /**
     * Nederlands
     * @type {string}
     * @memberof LocalizedFieldRequest
     */
    'nl'?: string;
    /**
     * Português
     * @type {string}
     * @memberof LocalizedFieldRequest
     */
    'pt'?: string;
    /**
     * Română
     * @type {string}
     * @memberof LocalizedFieldRequest
     */
    'ro'?: string;
    /**
     * Slovenščina
     * @type {string}
     * @memberof LocalizedFieldRequest
     */
    'sl'?: string;
    /**
     * Shqip
     * @type {string}
     * @memberof LocalizedFieldRequest
     */
    'sq'?: string;
    /**
     * Српски
     * @type {string}
     * @memberof LocalizedFieldRequest
     */
    'sr'?: string;
    /**
     * Svenska
     * @type {string}
     * @memberof LocalizedFieldRequest
     */
    'sv'?: string;
    /**
     * Türkçe
     * @type {string}
     * @memberof LocalizedFieldRequest
     */
    'tr'?: string;
    /**
     * 中文（中国）
     * @type {string}
     * @memberof LocalizedFieldRequest
     */
    'zh-CN'?: string;
}
/**
 * 
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * Did user indicate that report relates to current location of phone (\'current\') or to a location selected manually on the map (\'selected\')? Or is the choice missing (\'missing\')
     * @type {string}
     * @memberof Location
     */
    'type': LocationTypeEnum;
    /**
     * 
     * @type {LocationPoint}
     * @memberof Location
     */
    'point': LocationPoint | null;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'timezone': LocationTimezoneEnum | null;
    /**
     * 
     * @type {number}
     * @memberof Location
     */
    'country_id': number | null;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'nuts_2': string | null;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'nuts_3': string | null;
}

export const LocationTypeEnum = {
    Current: 'current',
    Selected: 'selected',
    Missing: 'missing'
} as const;

export type LocationTypeEnum = typeof LocationTypeEnum[keyof typeof LocationTypeEnum];
export const LocationTimezoneEnum = {
    AfricaAbidjan: 'Africa/Abidjan',
    AfricaAccra: 'Africa/Accra',
    AfricaAddisAbaba: 'Africa/Addis_Ababa',
    AfricaAlgiers: 'Africa/Algiers',
    AfricaAsmara: 'Africa/Asmara',
    AfricaBamako: 'Africa/Bamako',
    AfricaBangui: 'Africa/Bangui',
    AfricaBanjul: 'Africa/Banjul',
    AfricaBissau: 'Africa/Bissau',
    AfricaBlantyre: 'Africa/Blantyre',
    AfricaBrazzaville: 'Africa/Brazzaville',
    AfricaBujumbura: 'Africa/Bujumbura',
    AfricaCairo: 'Africa/Cairo',
    AfricaCasablanca: 'Africa/Casablanca',
    AfricaCeuta: 'Africa/Ceuta',
    AfricaConakry: 'Africa/Conakry',
    AfricaDakar: 'Africa/Dakar',
    AfricaDarEsSalaam: 'Africa/Dar_es_Salaam',
    AfricaDjibouti: 'Africa/Djibouti',
    AfricaDouala: 'Africa/Douala',
    AfricaElAaiun: 'Africa/El_Aaiun',
    AfricaFreetown: 'Africa/Freetown',
    AfricaGaborone: 'Africa/Gaborone',
    AfricaHarare: 'Africa/Harare',
    AfricaJohannesburg: 'Africa/Johannesburg',
    AfricaJuba: 'Africa/Juba',
    AfricaKampala: 'Africa/Kampala',
    AfricaKhartoum: 'Africa/Khartoum',
    AfricaKigali: 'Africa/Kigali',
    AfricaKinshasa: 'Africa/Kinshasa',
    AfricaLagos: 'Africa/Lagos',
    AfricaLibreville: 'Africa/Libreville',
    AfricaLome: 'Africa/Lome',
    AfricaLuanda: 'Africa/Luanda',
    AfricaLubumbashi: 'Africa/Lubumbashi',
    AfricaLusaka: 'Africa/Lusaka',
    AfricaMalabo: 'Africa/Malabo',
    AfricaMaputo: 'Africa/Maputo',
    AfricaMaseru: 'Africa/Maseru',
    AfricaMbabane: 'Africa/Mbabane',
    AfricaMogadishu: 'Africa/Mogadishu',
    AfricaMonrovia: 'Africa/Monrovia',
    AfricaNairobi: 'Africa/Nairobi',
    AfricaNdjamena: 'Africa/Ndjamena',
    AfricaNiamey: 'Africa/Niamey',
    AfricaNouakchott: 'Africa/Nouakchott',
    AfricaOuagadougou: 'Africa/Ouagadougou',
    AfricaPortoNovo: 'Africa/Porto-Novo',
    AfricaSaoTome: 'Africa/Sao_Tome',
    AfricaTripoli: 'Africa/Tripoli',
    AfricaTunis: 'Africa/Tunis',
    AfricaWindhoek: 'Africa/Windhoek',
    AmericaAdak: 'America/Adak',
    AmericaAnchorage: 'America/Anchorage',
    AmericaAnguilla: 'America/Anguilla',
    AmericaAntigua: 'America/Antigua',
    AmericaAraguaina: 'America/Araguaina',
    AmericaArgentinaBuenosAires: 'America/Argentina/Buenos_Aires',
    AmericaArgentinaCatamarca: 'America/Argentina/Catamarca',
    AmericaArgentinaCordoba: 'America/Argentina/Cordoba',
    AmericaArgentinaJujuy: 'America/Argentina/Jujuy',
    AmericaArgentinaLaRioja: 'America/Argentina/La_Rioja',
    AmericaArgentinaMendoza: 'America/Argentina/Mendoza',
    AmericaArgentinaRioGallegos: 'America/Argentina/Rio_Gallegos',
    AmericaArgentinaSalta: 'America/Argentina/Salta',
    AmericaArgentinaSanJuan: 'America/Argentina/San_Juan',
    AmericaArgentinaSanLuis: 'America/Argentina/San_Luis',
    AmericaArgentinaTucuman: 'America/Argentina/Tucuman',
    AmericaArgentinaUshuaia: 'America/Argentina/Ushuaia',
    AmericaAruba: 'America/Aruba',
    AmericaAsuncion: 'America/Asuncion',
    AmericaAtikokan: 'America/Atikokan',
    AmericaBahia: 'America/Bahia',
    AmericaBahiaBanderas: 'America/Bahia_Banderas',
    AmericaBarbados: 'America/Barbados',
    AmericaBelem: 'America/Belem',
    AmericaBelize: 'America/Belize',
    AmericaBlancSablon: 'America/Blanc-Sablon',
    AmericaBoaVista: 'America/Boa_Vista',
    AmericaBogota: 'America/Bogota',
    AmericaBoise: 'America/Boise',
    AmericaCambridgeBay: 'America/Cambridge_Bay',
    AmericaCampoGrande: 'America/Campo_Grande',
    AmericaCancun: 'America/Cancun',
    AmericaCaracas: 'America/Caracas',
    AmericaCayenne: 'America/Cayenne',
    AmericaCayman: 'America/Cayman',
    AmericaChicago: 'America/Chicago',
    AmericaChihuahua: 'America/Chihuahua',
    AmericaCiudadJuarez: 'America/Ciudad_Juarez',
    AmericaCostaRica: 'America/Costa_Rica',
    AmericaCreston: 'America/Creston',
    AmericaCuiaba: 'America/Cuiaba',
    AmericaCuracao: 'America/Curacao',
    AmericaDanmarkshavn: 'America/Danmarkshavn',
    AmericaDawson: 'America/Dawson',
    AmericaDawsonCreek: 'America/Dawson_Creek',
    AmericaDenver: 'America/Denver',
    AmericaDetroit: 'America/Detroit',
    AmericaDominica: 'America/Dominica',
    AmericaEdmonton: 'America/Edmonton',
    AmericaEirunepe: 'America/Eirunepe',
    AmericaElSalvador: 'America/El_Salvador',
    AmericaFortNelson: 'America/Fort_Nelson',
    AmericaFortaleza: 'America/Fortaleza',
    AmericaGlaceBay: 'America/Glace_Bay',
    AmericaGooseBay: 'America/Goose_Bay',
    AmericaGrandTurk: 'America/Grand_Turk',
    AmericaGrenada: 'America/Grenada',
    AmericaGuadeloupe: 'America/Guadeloupe',
    AmericaGuatemala: 'America/Guatemala',
    AmericaGuayaquil: 'America/Guayaquil',
    AmericaGuyana: 'America/Guyana',
    AmericaHalifax: 'America/Halifax',
    AmericaHavana: 'America/Havana',
    AmericaHermosillo: 'America/Hermosillo',
    AmericaIndianaIndianapolis: 'America/Indiana/Indianapolis',
    AmericaIndianaKnox: 'America/Indiana/Knox',
    AmericaIndianaMarengo: 'America/Indiana/Marengo',
    AmericaIndianaPetersburg: 'America/Indiana/Petersburg',
    AmericaIndianaTellCity: 'America/Indiana/Tell_City',
    AmericaIndianaVevay: 'America/Indiana/Vevay',
    AmericaIndianaVincennes: 'America/Indiana/Vincennes',
    AmericaIndianaWinamac: 'America/Indiana/Winamac',
    AmericaInuvik: 'America/Inuvik',
    AmericaIqaluit: 'America/Iqaluit',
    AmericaJamaica: 'America/Jamaica',
    AmericaJuneau: 'America/Juneau',
    AmericaKentuckyLouisville: 'America/Kentucky/Louisville',
    AmericaKentuckyMonticello: 'America/Kentucky/Monticello',
    AmericaKralendijk: 'America/Kralendijk',
    AmericaLaPaz: 'America/La_Paz',
    AmericaLima: 'America/Lima',
    AmericaLosAngeles: 'America/Los_Angeles',
    AmericaLowerPrinces: 'America/Lower_Princes',
    AmericaMaceio: 'America/Maceio',
    AmericaManagua: 'America/Managua',
    AmericaManaus: 'America/Manaus',
    AmericaMarigot: 'America/Marigot',
    AmericaMartinique: 'America/Martinique',
    AmericaMatamoros: 'America/Matamoros',
    AmericaMazatlan: 'America/Mazatlan',
    AmericaMenominee: 'America/Menominee',
    AmericaMerida: 'America/Merida',
    AmericaMetlakatla: 'America/Metlakatla',
    AmericaMexicoCity: 'America/Mexico_City',
    AmericaMiquelon: 'America/Miquelon',
    AmericaMoncton: 'America/Moncton',
    AmericaMonterrey: 'America/Monterrey',
    AmericaMontevideo: 'America/Montevideo',
    AmericaMontserrat: 'America/Montserrat',
    AmericaNassau: 'America/Nassau',
    AmericaNewYork: 'America/New_York',
    AmericaNome: 'America/Nome',
    AmericaNoronha: 'America/Noronha',
    AmericaNorthDakotaBeulah: 'America/North_Dakota/Beulah',
    AmericaNorthDakotaCenter: 'America/North_Dakota/Center',
    AmericaNorthDakotaNewSalem: 'America/North_Dakota/New_Salem',
    AmericaNuuk: 'America/Nuuk',
    AmericaOjinaga: 'America/Ojinaga',
    AmericaPanama: 'America/Panama',
    AmericaParamaribo: 'America/Paramaribo',
    AmericaPhoenix: 'America/Phoenix',
    AmericaPortAuPrince: 'America/Port-au-Prince',
    AmericaPortOfSpain: 'America/Port_of_Spain',
    AmericaPortoVelho: 'America/Porto_Velho',
    AmericaPuertoRico: 'America/Puerto_Rico',
    AmericaPuntaArenas: 'America/Punta_Arenas',
    AmericaRankinInlet: 'America/Rankin_Inlet',
    AmericaRecife: 'America/Recife',
    AmericaRegina: 'America/Regina',
    AmericaResolute: 'America/Resolute',
    AmericaRioBranco: 'America/Rio_Branco',
    AmericaSantarem: 'America/Santarem',
    AmericaSantiago: 'America/Santiago',
    AmericaSantoDomingo: 'America/Santo_Domingo',
    AmericaSaoPaulo: 'America/Sao_Paulo',
    AmericaScoresbysund: 'America/Scoresbysund',
    AmericaSitka: 'America/Sitka',
    AmericaStBarthelemy: 'America/St_Barthelemy',
    AmericaStJohns: 'America/St_Johns',
    AmericaStKitts: 'America/St_Kitts',
    AmericaStLucia: 'America/St_Lucia',
    AmericaStThomas: 'America/St_Thomas',
    AmericaStVincent: 'America/St_Vincent',
    AmericaSwiftCurrent: 'America/Swift_Current',
    AmericaTegucigalpa: 'America/Tegucigalpa',
    AmericaThule: 'America/Thule',
    AmericaTijuana: 'America/Tijuana',
    AmericaToronto: 'America/Toronto',
    AmericaTortola: 'America/Tortola',
    AmericaVancouver: 'America/Vancouver',
    AmericaWhitehorse: 'America/Whitehorse',
    AmericaWinnipeg: 'America/Winnipeg',
    AmericaYakutat: 'America/Yakutat',
    AntarcticaCasey: 'Antarctica/Casey',
    AntarcticaDavis: 'Antarctica/Davis',
    AntarcticaDumontDUrville: 'Antarctica/DumontDUrville',
    AntarcticaMacquarie: 'Antarctica/Macquarie',
    AntarcticaMawson: 'Antarctica/Mawson',
    AntarcticaMcMurdo: 'Antarctica/McMurdo',
    AntarcticaPalmer: 'Antarctica/Palmer',
    AntarcticaRothera: 'Antarctica/Rothera',
    AntarcticaSyowa: 'Antarctica/Syowa',
    AntarcticaTroll: 'Antarctica/Troll',
    AntarcticaVostok: 'Antarctica/Vostok',
    ArcticLongyearbyen: 'Arctic/Longyearbyen',
    AsiaAden: 'Asia/Aden',
    AsiaAlmaty: 'Asia/Almaty',
    AsiaAmman: 'Asia/Amman',
    AsiaAnadyr: 'Asia/Anadyr',
    AsiaAqtau: 'Asia/Aqtau',
    AsiaAqtobe: 'Asia/Aqtobe',
    AsiaAshgabat: 'Asia/Ashgabat',
    AsiaAtyrau: 'Asia/Atyrau',
    AsiaBaghdad: 'Asia/Baghdad',
    AsiaBahrain: 'Asia/Bahrain',
    AsiaBaku: 'Asia/Baku',
    AsiaBangkok: 'Asia/Bangkok',
    AsiaBarnaul: 'Asia/Barnaul',
    AsiaBeirut: 'Asia/Beirut',
    AsiaBishkek: 'Asia/Bishkek',
    AsiaBrunei: 'Asia/Brunei',
    AsiaChita: 'Asia/Chita',
    AsiaColombo: 'Asia/Colombo',
    AsiaDamascus: 'Asia/Damascus',
    AsiaDhaka: 'Asia/Dhaka',
    AsiaDili: 'Asia/Dili',
    AsiaDubai: 'Asia/Dubai',
    AsiaDushanbe: 'Asia/Dushanbe',
    AsiaFamagusta: 'Asia/Famagusta',
    AsiaGaza: 'Asia/Gaza',
    AsiaHebron: 'Asia/Hebron',
    AsiaHoChiMinh: 'Asia/Ho_Chi_Minh',
    AsiaHongKong: 'Asia/Hong_Kong',
    AsiaHovd: 'Asia/Hovd',
    AsiaIrkutsk: 'Asia/Irkutsk',
    AsiaJakarta: 'Asia/Jakarta',
    AsiaJayapura: 'Asia/Jayapura',
    AsiaJerusalem: 'Asia/Jerusalem',
    AsiaKabul: 'Asia/Kabul',
    AsiaKamchatka: 'Asia/Kamchatka',
    AsiaKarachi: 'Asia/Karachi',
    AsiaKathmandu: 'Asia/Kathmandu',
    AsiaKhandyga: 'Asia/Khandyga',
    AsiaKolkata: 'Asia/Kolkata',
    AsiaKrasnoyarsk: 'Asia/Krasnoyarsk',
    AsiaKualaLumpur: 'Asia/Kuala_Lumpur',
    AsiaKuching: 'Asia/Kuching',
    AsiaKuwait: 'Asia/Kuwait',
    AsiaMacau: 'Asia/Macau',
    AsiaMagadan: 'Asia/Magadan',
    AsiaMakassar: 'Asia/Makassar',
    AsiaManila: 'Asia/Manila',
    AsiaMuscat: 'Asia/Muscat',
    AsiaNicosia: 'Asia/Nicosia',
    AsiaNovokuznetsk: 'Asia/Novokuznetsk',
    AsiaNovosibirsk: 'Asia/Novosibirsk',
    AsiaOmsk: 'Asia/Omsk',
    AsiaOral: 'Asia/Oral',
    AsiaPhnomPenh: 'Asia/Phnom_Penh',
    AsiaPontianak: 'Asia/Pontianak',
    AsiaPyongyang: 'Asia/Pyongyang',
    AsiaQatar: 'Asia/Qatar',
    AsiaQostanay: 'Asia/Qostanay',
    AsiaQyzylorda: 'Asia/Qyzylorda',
    AsiaRiyadh: 'Asia/Riyadh',
    AsiaSakhalin: 'Asia/Sakhalin',
    AsiaSamarkand: 'Asia/Samarkand',
    AsiaSeoul: 'Asia/Seoul',
    AsiaShanghai: 'Asia/Shanghai',
    AsiaSingapore: 'Asia/Singapore',
    AsiaSrednekolymsk: 'Asia/Srednekolymsk',
    AsiaTaipei: 'Asia/Taipei',
    AsiaTashkent: 'Asia/Tashkent',
    AsiaTbilisi: 'Asia/Tbilisi',
    AsiaTehran: 'Asia/Tehran',
    AsiaThimphu: 'Asia/Thimphu',
    AsiaTokyo: 'Asia/Tokyo',
    AsiaTomsk: 'Asia/Tomsk',
    AsiaUlaanbaatar: 'Asia/Ulaanbaatar',
    AsiaUrumqi: 'Asia/Urumqi',
    AsiaUstNera: 'Asia/Ust-Nera',
    AsiaVientiane: 'Asia/Vientiane',
    AsiaVladivostok: 'Asia/Vladivostok',
    AsiaYakutsk: 'Asia/Yakutsk',
    AsiaYangon: 'Asia/Yangon',
    AsiaYekaterinburg: 'Asia/Yekaterinburg',
    AsiaYerevan: 'Asia/Yerevan',
    AtlanticAzores: 'Atlantic/Azores',
    AtlanticBermuda: 'Atlantic/Bermuda',
    AtlanticCanary: 'Atlantic/Canary',
    AtlanticCapeVerde: 'Atlantic/Cape_Verde',
    AtlanticFaroe: 'Atlantic/Faroe',
    AtlanticMadeira: 'Atlantic/Madeira',
    AtlanticReykjavik: 'Atlantic/Reykjavik',
    AtlanticSouthGeorgia: 'Atlantic/South_Georgia',
    AtlanticStHelena: 'Atlantic/St_Helena',
    AtlanticStanley: 'Atlantic/Stanley',
    AustraliaAdelaide: 'Australia/Adelaide',
    AustraliaBrisbane: 'Australia/Brisbane',
    AustraliaBrokenHill: 'Australia/Broken_Hill',
    AustraliaDarwin: 'Australia/Darwin',
    AustraliaEucla: 'Australia/Eucla',
    AustraliaHobart: 'Australia/Hobart',
    AustraliaLindeman: 'Australia/Lindeman',
    AustraliaLordHowe: 'Australia/Lord_Howe',
    AustraliaMelbourne: 'Australia/Melbourne',
    AustraliaPerth: 'Australia/Perth',
    AustraliaSydney: 'Australia/Sydney',
    CanadaAtlantic: 'Canada/Atlantic',
    CanadaCentral: 'Canada/Central',
    CanadaEastern: 'Canada/Eastern',
    CanadaMountain: 'Canada/Mountain',
    CanadaNewfoundland: 'Canada/Newfoundland',
    CanadaPacific: 'Canada/Pacific',
    EuropeAmsterdam: 'Europe/Amsterdam',
    EuropeAndorra: 'Europe/Andorra',
    EuropeAstrakhan: 'Europe/Astrakhan',
    EuropeAthens: 'Europe/Athens',
    EuropeBelgrade: 'Europe/Belgrade',
    EuropeBerlin: 'Europe/Berlin',
    EuropeBratislava: 'Europe/Bratislava',
    EuropeBrussels: 'Europe/Brussels',
    EuropeBucharest: 'Europe/Bucharest',
    EuropeBudapest: 'Europe/Budapest',
    EuropeBusingen: 'Europe/Busingen',
    EuropeChisinau: 'Europe/Chisinau',
    EuropeCopenhagen: 'Europe/Copenhagen',
    EuropeDublin: 'Europe/Dublin',
    EuropeGibraltar: 'Europe/Gibraltar',
    EuropeGuernsey: 'Europe/Guernsey',
    EuropeHelsinki: 'Europe/Helsinki',
    EuropeIsleOfMan: 'Europe/Isle_of_Man',
    EuropeIstanbul: 'Europe/Istanbul',
    EuropeJersey: 'Europe/Jersey',
    EuropeKaliningrad: 'Europe/Kaliningrad',
    EuropeKirov: 'Europe/Kirov',
    EuropeKyiv: 'Europe/Kyiv',
    EuropeLisbon: 'Europe/Lisbon',
    EuropeLjubljana: 'Europe/Ljubljana',
    EuropeLondon: 'Europe/London',
    EuropeLuxembourg: 'Europe/Luxembourg',
    EuropeMadrid: 'Europe/Madrid',
    EuropeMalta: 'Europe/Malta',
    EuropeMariehamn: 'Europe/Mariehamn',
    EuropeMinsk: 'Europe/Minsk',
    EuropeMonaco: 'Europe/Monaco',
    EuropeMoscow: 'Europe/Moscow',
    EuropeOslo: 'Europe/Oslo',
    EuropeParis: 'Europe/Paris',
    EuropePodgorica: 'Europe/Podgorica',
    EuropePrague: 'Europe/Prague',
    EuropeRiga: 'Europe/Riga',
    EuropeRome: 'Europe/Rome',
    EuropeSamara: 'Europe/Samara',
    EuropeSanMarino: 'Europe/San_Marino',
    EuropeSarajevo: 'Europe/Sarajevo',
    EuropeSaratov: 'Europe/Saratov',
    EuropeSimferopol: 'Europe/Simferopol',
    EuropeSkopje: 'Europe/Skopje',
    EuropeSofia: 'Europe/Sofia',
    EuropeStockholm: 'Europe/Stockholm',
    EuropeTallinn: 'Europe/Tallinn',
    EuropeTirane: 'Europe/Tirane',
    EuropeUlyanovsk: 'Europe/Ulyanovsk',
    EuropeVaduz: 'Europe/Vaduz',
    EuropeVatican: 'Europe/Vatican',
    EuropeVienna: 'Europe/Vienna',
    EuropeVilnius: 'Europe/Vilnius',
    EuropeVolgograd: 'Europe/Volgograd',
    EuropeWarsaw: 'Europe/Warsaw',
    EuropeZagreb: 'Europe/Zagreb',
    EuropeZurich: 'Europe/Zurich',
    Gmt: 'GMT',
    IndianAntananarivo: 'Indian/Antananarivo',
    IndianChagos: 'Indian/Chagos',
    IndianChristmas: 'Indian/Christmas',
    IndianCocos: 'Indian/Cocos',
    IndianComoro: 'Indian/Comoro',
    IndianKerguelen: 'Indian/Kerguelen',
    IndianMahe: 'Indian/Mahe',
    IndianMaldives: 'Indian/Maldives',
    IndianMauritius: 'Indian/Mauritius',
    IndianMayotte: 'Indian/Mayotte',
    IndianReunion: 'Indian/Reunion',
    PacificApia: 'Pacific/Apia',
    PacificAuckland: 'Pacific/Auckland',
    PacificBougainville: 'Pacific/Bougainville',
    PacificChatham: 'Pacific/Chatham',
    PacificChuuk: 'Pacific/Chuuk',
    PacificEaster: 'Pacific/Easter',
    PacificEfate: 'Pacific/Efate',
    PacificFakaofo: 'Pacific/Fakaofo',
    PacificFiji: 'Pacific/Fiji',
    PacificFunafuti: 'Pacific/Funafuti',
    PacificGalapagos: 'Pacific/Galapagos',
    PacificGambier: 'Pacific/Gambier',
    PacificGuadalcanal: 'Pacific/Guadalcanal',
    PacificGuam: 'Pacific/Guam',
    PacificHonolulu: 'Pacific/Honolulu',
    PacificKanton: 'Pacific/Kanton',
    PacificKiritimati: 'Pacific/Kiritimati',
    PacificKosrae: 'Pacific/Kosrae',
    PacificKwajalein: 'Pacific/Kwajalein',
    PacificMajuro: 'Pacific/Majuro',
    PacificMarquesas: 'Pacific/Marquesas',
    PacificMidway: 'Pacific/Midway',
    PacificNauru: 'Pacific/Nauru',
    PacificNiue: 'Pacific/Niue',
    PacificNorfolk: 'Pacific/Norfolk',
    PacificNoumea: 'Pacific/Noumea',
    PacificPagoPago: 'Pacific/Pago_Pago',
    PacificPalau: 'Pacific/Palau',
    PacificPitcairn: 'Pacific/Pitcairn',
    PacificPohnpei: 'Pacific/Pohnpei',
    PacificPortMoresby: 'Pacific/Port_Moresby',
    PacificRarotonga: 'Pacific/Rarotonga',
    PacificSaipan: 'Pacific/Saipan',
    PacificTahiti: 'Pacific/Tahiti',
    PacificTarawa: 'Pacific/Tarawa',
    PacificTongatapu: 'Pacific/Tongatapu',
    PacificWake: 'Pacific/Wake',
    PacificWallis: 'Pacific/Wallis',
    UsAlaska: 'US/Alaska',
    UsArizona: 'US/Arizona',
    UsCentral: 'US/Central',
    UsEastern: 'US/Eastern',
    UsHawaii: 'US/Hawaii',
    UsMountain: 'US/Mountain',
    UsPacific: 'US/Pacific',
    Utc: 'UTC'
} as const;

export type LocationTimezoneEnum = typeof LocationTimezoneEnum[keyof typeof LocationTimezoneEnum];

/**
 * 
 * @export
 * @interface LocationPoint
 */
export interface LocationPoint {
    /**
     * 
     * @type {number}
     * @memberof LocationPoint
     */
    'latitude': number;
    /**
     * 
     * @type {number}
     * @memberof LocationPoint
     */
    'longitude': number;
}
/**
 * 
 * @export
 * @interface LocationRequest
 */
export interface LocationRequest {
    /**
     * Did user indicate that report relates to current location of phone (\'current\') or to a location selected manually on the map (\'selected\')? Or is the choice missing (\'missing\')
     * @type {string}
     * @memberof LocationRequest
     */
    'type': LocationRequestTypeEnum;
    /**
     * 
     * @type {LocationPoint}
     * @memberof LocationRequest
     */
    'point': LocationPoint | null;
}

export const LocationRequestTypeEnum = {
    Current: 'current',
    Selected: 'selected',
    Missing: 'missing'
} as const;

export type LocationRequestTypeEnum = typeof LocationRequestTypeEnum[keyof typeof LocationRequestTypeEnum];

/**
 * @type MetaNotificationRequest
 * @export
 */
export type MetaNotificationRequest = { receiver_type: 'topic' } & TopicNotificationCreateRequest | { receiver_type: 'user' } & UserNotificationCreateRequest;

/**
 * 
 * @export
 * @interface MobileApp
 */
export interface MobileApp {
    /**
     * 
     * @type {string}
     * @memberof MobileApp
     */
    'package_name': string;
    /**
     * 
     * @type {string}
     * @memberof MobileApp
     */
    'package_version': string;
}
/**
 * 
 * @export
 * @interface MobileAppRequest
 */
export interface MobileAppRequest {
    /**
     * 
     * @type {string}
     * @memberof MobileAppRequest
     */
    'package_name': string;
    /**
     * 
     * @type {string}
     * @memberof MobileAppRequest
     */
    'package_version': string;
}
/**
 * 
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     * 
     * @type {number}
     * @memberof Notification
     */
    'id': number;
    /**
     * 
     * @type {NotificationMessage}
     * @memberof Notification
     */
    'message': NotificationMessage;
    /**
     * 
     * @type {boolean}
     * @memberof Notification
     */
    'is_read': boolean;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface NotificationMessage
 */
export interface NotificationMessage {
    /**
     * 
     * @type {string}
     * @memberof NotificationMessage
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationMessage
     */
    'body': string;
}
/**
 * 
 * @export
 * @interface NotificationRequest
 */
export interface NotificationRequest {
    /**
     * 
     * @type {boolean}
     * @memberof NotificationRequest
     */
    'is_read': boolean;
}
/**
 * 
 * @export
 * @interface Observation
 */
export interface Observation {
    /**
     * 
     * @type {string}
     * @memberof Observation
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof Observation
     */
    'short_id': string;
    /**
     * 
     * @type {string}
     * @memberof Observation
     */
    'user_uuid': string;
    /**
     * 
     * @type {string}
     * @memberof Observation
     */
    'created_at': string;
    /**
     * The date and time when the record was created, displayed in the local timezone specified for this entry.
     * @type {string}
     * @memberof Observation
     */
    'created_at_local': string;
    /**
     * 
     * @type {string}
     * @memberof Observation
     */
    'sent_at': string;
    /**
     * 
     * @type {string}
     * @memberof Observation
     */
    'received_at': string;
    /**
     * Date and time when the report was last modified
     * @type {string}
     * @memberof Observation
     */
    'updated_at': string;
    /**
     * 
     * @type {Location}
     * @memberof Observation
     */
    'location': Location;
    /**
     * Note user attached to report.
     * @type {string}
     * @memberof Observation
     */
    'note'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Observation
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Observation
     */
    'published': boolean;
    /**
     * 
     * @type {Array<SimplePhoto>}
     * @memberof Observation
     */
    'photos': Array<SimplePhoto>;
    /**
     * The environment where the event took place.
     * @type {string}
     * @memberof Observation
     */
    'event_environment'?: ObservationEventEnvironmentEnum | null;
    /**
     * The moment of the day when the event took place.
     * @type {string}
     * @memberof Observation
     */
    'event_moment'?: ObservationEventMomentEnum | null;
    /**
     * The mosquito specie perceived by the user.
     * @type {string}
     * @memberof Observation
     */
    'user_perceived_mosquito_specie'?: ObservationUserPerceivedMosquitoSpecieEnum | null;
    /**
     * The species of mosquito that the thorax resembles, according to the user.
     * @type {string}
     * @memberof Observation
     */
    'user_perceived_mosquito_thorax'?: ObservationUserPerceivedMosquitoThoraxEnum | null;
    /**
     * The species of mosquito that the abdomen resembles, according to the user.
     * @type {string}
     * @memberof Observation
     */
    'user_perceived_mosquito_abdomen'?: ObservationUserPerceivedMosquitoAbdomenEnum | null;
    /**
     * The species of mosquito that the leg resembles, according to the user.
     * @type {string}
     * @memberof Observation
     */
    'user_perceived_mosquito_legs'?: ObservationUserPerceivedMosquitoLegsEnum | null;
}

export const ObservationEventEnvironmentEnum = {
    Indoors: 'indoors',
    Outdoors: 'outdoors',
    Vehicle: 'vehicle',
    Empty: ''
} as const;

export type ObservationEventEnvironmentEnum = typeof ObservationEventEnvironmentEnum[keyof typeof ObservationEventEnvironmentEnum];
export const ObservationEventMomentEnum = {
    Now: 'now',
    LastMorning: 'last_morning',
    LastMidday: 'last_midday',
    LastAfternoon: 'last_afternoon',
    LastNight: 'last_night',
    Empty: ''
} as const;

export type ObservationEventMomentEnum = typeof ObservationEventMomentEnum[keyof typeof ObservationEventMomentEnum];
export const ObservationUserPerceivedMosquitoSpecieEnum = {
    Albopictus: 'albopictus',
    Aegypti: 'aegypti',
    Japonicus: 'japonicus',
    Koreicus: 'koreicus',
    Culex: 'culex',
    Other: 'other',
    Empty: ''
} as const;

export type ObservationUserPerceivedMosquitoSpecieEnum = typeof ObservationUserPerceivedMosquitoSpecieEnum[keyof typeof ObservationUserPerceivedMosquitoSpecieEnum];
export const ObservationUserPerceivedMosquitoThoraxEnum = {
    Albopictus: 'albopictus',
    Aegypti: 'aegypti',
    Japonicus: 'japonicus',
    Koreicus: 'koreicus',
    Culex: 'culex',
    Other: 'other',
    Empty: ''
} as const;

export type ObservationUserPerceivedMosquitoThoraxEnum = typeof ObservationUserPerceivedMosquitoThoraxEnum[keyof typeof ObservationUserPerceivedMosquitoThoraxEnum];
export const ObservationUserPerceivedMosquitoAbdomenEnum = {
    Albopictus: 'albopictus',
    Aegypti: 'aegypti',
    Japonicus: 'japonicus',
    Koreicus: 'koreicus',
    Culex: 'culex',
    Other: 'other',
    Empty: ''
} as const;

export type ObservationUserPerceivedMosquitoAbdomenEnum = typeof ObservationUserPerceivedMosquitoAbdomenEnum[keyof typeof ObservationUserPerceivedMosquitoAbdomenEnum];
export const ObservationUserPerceivedMosquitoLegsEnum = {
    Albopictus: 'albopictus',
    Aegypti: 'aegypti',
    Japonicus: 'japonicus',
    Koreicus: 'koreicus',
    Culex: 'culex',
    Other: 'other',
    Empty: ''
} as const;

export type ObservationUserPerceivedMosquitoLegsEnum = typeof ObservationUserPerceivedMosquitoLegsEnum[keyof typeof ObservationUserPerceivedMosquitoLegsEnum];

/**
 * 
 * @export
 * @interface ObservationPrediction
 */
export interface ObservationPrediction {
    /**
     * The selected photo whose prediction represents the observation as the best classification result.
     * @type {string}
     * @memberof ObservationPrediction
     */
    'ref_photo_uuid': string;
    /**
     * 
     * @type {number}
     * @memberof ObservationPrediction
     */
    'insect_confidence': number;
    /**
     * 
     * @type {string}
     * @memberof ObservationPrediction
     */
    'predicted_class': ObservationPredictionPredictedClassEnum;
    /**
     * 
     * @type {string}
     * @memberof ObservationPrediction
     */
    'predicted_class_display': ObservationPredictionPredictedClassDisplayEnum;
    /**
     * Whether if the photo prediction will be used as an executive validation for the report.
     * @type {boolean}
     * @memberof ObservationPrediction
     */
    'is_executive_validation': boolean;
    /**
     * 
     * @type {string}
     * @memberof ObservationPrediction
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ObservationPrediction
     */
    'updated_at': string;
}

export const ObservationPredictionPredictedClassEnum = {
    AeAlbopictus: 'ae_albopictus',
    AeAegypti: 'ae_aegypti',
    AeJaponicus: 'ae_japonicus',
    AeKoreicus: 'ae_koreicus',
    Culex: 'culex',
    Anopheles: 'anopheles',
    Culiseta: 'culiseta',
    OtherSpecies: 'other_species',
    NotSure: 'not_sure'
} as const;

export type ObservationPredictionPredictedClassEnum = typeof ObservationPredictionPredictedClassEnum[keyof typeof ObservationPredictionPredictedClassEnum];
export const ObservationPredictionPredictedClassDisplayEnum = {
    AedesAlbopictus: 'Aedes albopictus',
    AedesAegypti: 'Aedes aegypti',
    AedesJaponicus: 'Aedes japonicus',
    AedesKoreicus: 'Aedes koreicus',
    CulexSP: 'Culex (s.p)',
    AnophelesSP: 'Anopheles (s.p.)',
    CulisetaSP: 'Culiseta (s.p.)',
    OhterSpecies: 'Ohter species',
    Unidentifiable: 'Unidentifiable'
} as const;

export type ObservationPredictionPredictedClassDisplayEnum = typeof ObservationPredictionPredictedClassDisplayEnum[keyof typeof ObservationPredictionPredictedClassDisplayEnum];

/**
 * 
 * @export
 * @interface ObservationPredictionRequest
 */
export interface ObservationPredictionRequest {
    /**
     * The selected photo whose prediction represents the observation as the best classification result.
     * @type {string}
     * @memberof ObservationPredictionRequest
     */
    'ref_photo_uuid': string;
    /**
     * Whether if the photo prediction will be used as an executive validation for the report.
     * @type {boolean}
     * @memberof ObservationPredictionRequest
     */
    'is_executive_validation'?: boolean;
}
/**
 * 
 * @export
 * @interface ObservationRequest
 */
export interface ObservationRequest {
    /**
     * 
     * @type {string}
     * @memberof ObservationRequest
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ObservationRequest
     */
    'sent_at': string;
    /**
     * 
     * @type {LocationRequest}
     * @memberof ObservationRequest
     */
    'location': LocationRequest;
    /**
     * Note user attached to report.
     * @type {string}
     * @memberof ObservationRequest
     */
    'note'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ObservationRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<SimplePhotoRequest>}
     * @memberof ObservationRequest
     */
    'photos': Array<SimplePhotoRequest>;
    /**
     * The environment where the event took place.
     * @type {string}
     * @memberof ObservationRequest
     */
    'event_environment'?: ObservationRequestEventEnvironmentEnum | null;
    /**
     * The moment of the day when the event took place.
     * @type {string}
     * @memberof ObservationRequest
     */
    'event_moment'?: ObservationRequestEventMomentEnum | null;
    /**
     * The mosquito specie perceived by the user.
     * @type {string}
     * @memberof ObservationRequest
     */
    'user_perceived_mosquito_specie'?: ObservationRequestUserPerceivedMosquitoSpecieEnum | null;
    /**
     * The species of mosquito that the thorax resembles, according to the user.
     * @type {string}
     * @memberof ObservationRequest
     */
    'user_perceived_mosquito_thorax'?: ObservationRequestUserPerceivedMosquitoThoraxEnum | null;
    /**
     * The species of mosquito that the abdomen resembles, according to the user.
     * @type {string}
     * @memberof ObservationRequest
     */
    'user_perceived_mosquito_abdomen'?: ObservationRequestUserPerceivedMosquitoAbdomenEnum | null;
    /**
     * The species of mosquito that the leg resembles, according to the user.
     * @type {string}
     * @memberof ObservationRequest
     */
    'user_perceived_mosquito_legs'?: ObservationRequestUserPerceivedMosquitoLegsEnum | null;
}

export const ObservationRequestEventEnvironmentEnum = {
    Indoors: 'indoors',
    Outdoors: 'outdoors',
    Vehicle: 'vehicle',
    Empty: ''
} as const;

export type ObservationRequestEventEnvironmentEnum = typeof ObservationRequestEventEnvironmentEnum[keyof typeof ObservationRequestEventEnvironmentEnum];
export const ObservationRequestEventMomentEnum = {
    Now: 'now',
    LastMorning: 'last_morning',
    LastMidday: 'last_midday',
    LastAfternoon: 'last_afternoon',
    LastNight: 'last_night',
    Empty: ''
} as const;

export type ObservationRequestEventMomentEnum = typeof ObservationRequestEventMomentEnum[keyof typeof ObservationRequestEventMomentEnum];
export const ObservationRequestUserPerceivedMosquitoSpecieEnum = {
    Albopictus: 'albopictus',
    Aegypti: 'aegypti',
    Japonicus: 'japonicus',
    Koreicus: 'koreicus',
    Culex: 'culex',
    Other: 'other',
    Empty: ''
} as const;

export type ObservationRequestUserPerceivedMosquitoSpecieEnum = typeof ObservationRequestUserPerceivedMosquitoSpecieEnum[keyof typeof ObservationRequestUserPerceivedMosquitoSpecieEnum];
export const ObservationRequestUserPerceivedMosquitoThoraxEnum = {
    Albopictus: 'albopictus',
    Aegypti: 'aegypti',
    Japonicus: 'japonicus',
    Koreicus: 'koreicus',
    Culex: 'culex',
    Other: 'other',
    Empty: ''
} as const;

export type ObservationRequestUserPerceivedMosquitoThoraxEnum = typeof ObservationRequestUserPerceivedMosquitoThoraxEnum[keyof typeof ObservationRequestUserPerceivedMosquitoThoraxEnum];
export const ObservationRequestUserPerceivedMosquitoAbdomenEnum = {
    Albopictus: 'albopictus',
    Aegypti: 'aegypti',
    Japonicus: 'japonicus',
    Koreicus: 'koreicus',
    Culex: 'culex',
    Other: 'other',
    Empty: ''
} as const;

export type ObservationRequestUserPerceivedMosquitoAbdomenEnum = typeof ObservationRequestUserPerceivedMosquitoAbdomenEnum[keyof typeof ObservationRequestUserPerceivedMosquitoAbdomenEnum];
export const ObservationRequestUserPerceivedMosquitoLegsEnum = {
    Albopictus: 'albopictus',
    Aegypti: 'aegypti',
    Japonicus: 'japonicus',
    Koreicus: 'koreicus',
    Culex: 'culex',
    Other: 'other',
    Empty: ''
} as const;

export type ObservationRequestUserPerceivedMosquitoLegsEnum = typeof ObservationRequestUserPerceivedMosquitoLegsEnum[keyof typeof ObservationRequestUserPerceivedMosquitoLegsEnum];

/**
 * 
 * @export
 * @interface PaginatedBiteList
 */
export interface PaginatedBiteList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedBiteList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedBiteList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedBiteList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Bite>}
     * @memberof PaginatedBiteList
     */
    'results'?: Array<Bite>;
}
/**
 * 
 * @export
 * @interface PaginatedBreedingSiteList
 */
export interface PaginatedBreedingSiteList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedBreedingSiteList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedBreedingSiteList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedBreedingSiteList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<BreedingSite>}
     * @memberof PaginatedBreedingSiteList
     */
    'results'?: Array<BreedingSite>;
}
/**
 * 
 * @export
 * @interface PaginatedCampaignList
 */
export interface PaginatedCampaignList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedCampaignList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCampaignList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCampaignList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Campaign>}
     * @memberof PaginatedCampaignList
     */
    'results'?: Array<Campaign>;
}
/**
 * 
 * @export
 * @interface PaginatedNotificationList
 */
export interface PaginatedNotificationList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedNotificationList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedNotificationList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedNotificationList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Notification>}
     * @memberof PaginatedNotificationList
     */
    'results'?: Array<Notification>;
}
/**
 * 
 * @export
 * @interface PaginatedObservationList
 */
export interface PaginatedObservationList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedObservationList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedObservationList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedObservationList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Observation>}
     * @memberof PaginatedObservationList
     */
    'results'?: Array<Observation>;
}
/**
 * 
 * @export
 * @interface PaginatedPartnerList
 */
export interface PaginatedPartnerList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPartnerList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPartnerList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPartnerList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Partner>}
     * @memberof PaginatedPartnerList
     */
    'results'?: Array<Partner>;
}
/**
 * 
 * @export
 * @interface Partner
 */
export interface Partner {
    /**
     * 
     * @type {number}
     * @memberof Partner
     */
    'id': number;
    /**
     * 
     * @type {PartnerPoint}
     * @memberof Partner
     */
    'point': PartnerPoint;
    /**
     * Text desription on the pin. This text is meant to be visualized as the text body of the dialog on the map
     * @type {string}
     * @memberof Partner
     */
    'description': string;
    /**
     * URL link to the organization page
     * @type {string}
     * @memberof Partner
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface PartnerPoint
 */
export interface PartnerPoint {
    /**
     * 
     * @type {number}
     * @memberof PartnerPoint
     */
    'latitude': number;
    /**
     * 
     * @type {number}
     * @memberof PartnerPoint
     */
    'longitude': number;
}
/**
 * 
 * @export
 * @interface PatchedDeviceUpdateRequest
 */
export interface PatchedDeviceUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedDeviceUpdateRequest
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedDeviceUpdateRequest
     */
    'fcm_token'?: string;
    /**
     * 
     * @type {DeviceOsRequest}
     * @memberof PatchedDeviceUpdateRequest
     */
    'os'?: DeviceOsRequest;
    /**
     * 
     * @type {MobileAppRequest}
     * @memberof PatchedDeviceUpdateRequest
     */
    'mobile_app'?: MobileAppRequest;
}
/**
 * 
 * @export
 * @interface PatchedNotificationRequest
 */
export interface PatchedNotificationRequest {
    /**
     * 
     * @type {boolean}
     * @memberof PatchedNotificationRequest
     */
    'is_read'?: boolean;
}
/**
 * 
 * @export
 * @interface PatchedUserRequest
 */
export interface PatchedUserRequest {
    /**
     * The locale code representing the language preference selected by the user for displaying the interface text. Enter the locale following the BCP 47 standard in \'language\' or \'language-region\' format (e.g., \'en\' for English, \'en-US\' for English (United States), \'fr\' for French). The language is a two-letter ISO 639-1 code, and the region is an optional two-letter ISO 3166-1 alpha-2 code.
     * @type {string}
     * @memberof PatchedUserRequest
     */
    'locale'?: PatchedUserRequestLocaleEnum;
}

export const PatchedUserRequestLocaleEnum = {
    Es: 'es',
    Ca: 'ca',
    Eu: 'eu',
    Bn: 'bn',
    Sv: 'sv',
    En: 'en',
    De: 'de',
    Sq: 'sq',
    El: 'el',
    Gl: 'gl',
    Hu: 'hu',
    Pt: 'pt',
    Sl: 'sl',
    It: 'it',
    Fr: 'fr',
    Bg: 'bg',
    Ro: 'ro',
    Hr: 'hr',
    Mk: 'mk',
    Sr: 'sr',
    Lb: 'lb',
    Nl: 'nl',
    Tr: 'tr',
    ZhCn: 'zh-CN'
} as const;

export type PatchedUserRequestLocaleEnum = typeof PatchedUserRequestLocaleEnum[keyof typeof PatchedUserRequestLocaleEnum];

/**
 * 
 * @export
 * @interface Photo
 */
export interface Photo {
    /**
     * 
     * @type {string}
     * @memberof Photo
     */
    'uuid'?: string;
    /**
     * Photo uploaded by user.
     * @type {string}
     * @memberof Photo
     */
    'image_url': string;
    /**
     * Internal server path of the image.
     * @type {string}
     * @memberof Photo
     */
    'image_path': string;
}
/**
 * 
 * @export
 * @interface PhotoPrediction
 */
export interface PhotoPrediction {
    /**
     * 
     * @type {BoundingBox}
     * @memberof PhotoPrediction
     */
    'bbox': BoundingBox;
    /**
     * Insect confidence
     * @type {number}
     * @memberof PhotoPrediction
     */
    'insect_confidence': number;
    /**
     * 
     * @type {string}
     * @memberof PhotoPrediction
     */
    'predicted_class'?: PhotoPredictionPredictedClassEnum;
    /**
     * 
     * @type {number}
     * @memberof PhotoPrediction
     */
    'threshold_deviation': number;
    /**
     * 
     * @type {PredictionScore}
     * @memberof PhotoPrediction
     */
    'scores': PredictionScore;
    /**
     * 
     * @type {string}
     * @memberof PhotoPrediction
     */
    'classifier_version': PhotoPredictionClassifierVersionEnum;
    /**
     * 
     * @type {string}
     * @memberof PhotoPrediction
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof PhotoPrediction
     */
    'updated_at': string;
}

export const PhotoPredictionPredictedClassEnum = {
    AeAlbopictus: 'ae_albopictus',
    AeAegypti: 'ae_aegypti',
    AeJaponicus: 'ae_japonicus',
    AeKoreicus: 'ae_koreicus',
    Culex: 'culex',
    Anopheles: 'anopheles',
    Culiseta: 'culiseta',
    OtherSpecies: 'other_species',
    NotSure: 'not_sure'
} as const;

export type PhotoPredictionPredictedClassEnum = typeof PhotoPredictionPredictedClassEnum[keyof typeof PhotoPredictionPredictedClassEnum];
export const PhotoPredictionClassifierVersionEnum = {
    V20231: 'v2023.1',
    V20241: 'v2024.1',
    V20251: 'v2025.1'
} as const;

export type PhotoPredictionClassifierVersionEnum = typeof PhotoPredictionClassifierVersionEnum[keyof typeof PhotoPredictionClassifierVersionEnum];

/**
 * 
 * @export
 * @interface PhotoPredictionRequest
 */
export interface PhotoPredictionRequest {
    /**
     * 
     * @type {BoundingBoxRequest}
     * @memberof PhotoPredictionRequest
     */
    'bbox': BoundingBoxRequest;
    /**
     * Insect confidence
     * @type {number}
     * @memberof PhotoPredictionRequest
     */
    'insect_confidence': number;
    /**
     * 
     * @type {string}
     * @memberof PhotoPredictionRequest
     */
    'predicted_class'?: PhotoPredictionRequestPredictedClassEnum;
    /**
     * 
     * @type {number}
     * @memberof PhotoPredictionRequest
     */
    'threshold_deviation': number;
    /**
     * 
     * @type {PredictionScoreRequest}
     * @memberof PhotoPredictionRequest
     */
    'scores': PredictionScoreRequest;
    /**
     * 
     * @type {string}
     * @memberof PhotoPredictionRequest
     */
    'classifier_version': PhotoPredictionRequestClassifierVersionEnum;
}

export const PhotoPredictionRequestPredictedClassEnum = {
    AeAlbopictus: 'ae_albopictus',
    AeAegypti: 'ae_aegypti',
    AeJaponicus: 'ae_japonicus',
    AeKoreicus: 'ae_koreicus',
    Culex: 'culex',
    Anopheles: 'anopheles',
    Culiseta: 'culiseta',
    OtherSpecies: 'other_species',
    NotSure: 'not_sure'
} as const;

export type PhotoPredictionRequestPredictedClassEnum = typeof PhotoPredictionRequestPredictedClassEnum[keyof typeof PhotoPredictionRequestPredictedClassEnum];
export const PhotoPredictionRequestClassifierVersionEnum = {
    V20231: 'v2023.1',
    V20241: 'v2024.1',
    V20251: 'v2025.1'
} as const;

export type PhotoPredictionRequestClassifierVersionEnum = typeof PhotoPredictionRequestClassifierVersionEnum[keyof typeof PhotoPredictionRequestClassifierVersionEnum];

/**
 * 
 * @export
 * @interface PredictionScore
 */
export interface PredictionScore {
    /**
     * Score value for the class Aedes albopictus
     * @type {number}
     * @memberof PredictionScore
     */
    'ae_albopictus': number;
    /**
     * Score value for the class Aedes aegypti
     * @type {number}
     * @memberof PredictionScore
     */
    'ae_aegypti': number;
    /**
     * Score value for the class Aedes japonicus
     * @type {number}
     * @memberof PredictionScore
     */
    'ae_japonicus': number;
    /**
     * Score value for the class Aedes koreicus
     * @type {number}
     * @memberof PredictionScore
     */
    'ae_koreicus': number;
    /**
     * Score value for the class Culex (s.p)
     * @type {number}
     * @memberof PredictionScore
     */
    'culex': number;
    /**
     * Score value for the class Anopheles (s.p.)
     * @type {number}
     * @memberof PredictionScore
     */
    'anopheles': number;
    /**
     * Score value for the class Culiseta (s.p.)
     * @type {number}
     * @memberof PredictionScore
     */
    'culiseta': number;
    /**
     * Score value for the class Ohter species
     * @type {number}
     * @memberof PredictionScore
     */
    'other_species': number;
    /**
     * Score value for the class Unidentifiable
     * @type {number}
     * @memberof PredictionScore
     */
    'not_sure': number;
}
/**
 * 
 * @export
 * @interface PredictionScoreRequest
 */
export interface PredictionScoreRequest {
    /**
     * Score value for the class Aedes albopictus
     * @type {number}
     * @memberof PredictionScoreRequest
     */
    'ae_albopictus': number;
    /**
     * Score value for the class Aedes aegypti
     * @type {number}
     * @memberof PredictionScoreRequest
     */
    'ae_aegypti': number;
    /**
     * Score value for the class Aedes japonicus
     * @type {number}
     * @memberof PredictionScoreRequest
     */
    'ae_japonicus': number;
    /**
     * Score value for the class Aedes koreicus
     * @type {number}
     * @memberof PredictionScoreRequest
     */
    'ae_koreicus': number;
    /**
     * Score value for the class Culex (s.p)
     * @type {number}
     * @memberof PredictionScoreRequest
     */
    'culex': number;
    /**
     * Score value for the class Anopheles (s.p.)
     * @type {number}
     * @memberof PredictionScoreRequest
     */
    'anopheles': number;
    /**
     * Score value for the class Culiseta (s.p.)
     * @type {number}
     * @memberof PredictionScoreRequest
     */
    'culiseta': number;
    /**
     * Score value for the class Ohter species
     * @type {number}
     * @memberof PredictionScoreRequest
     */
    'other_species': number;
    /**
     * Score value for the class Unidentifiable
     * @type {number}
     * @memberof PredictionScoreRequest
     */
    'not_sure': number;
}
/**
 * 
 * @export
 * @interface SimplePhoto
 */
export interface SimplePhoto {
    /**
     * 
     * @type {string}
     * @memberof SimplePhoto
     */
    'uuid': string;
    /**
     * URL of the photo associated with the item. Note: This URL may change over time. Do not rely on it for permanent storage.
     * @type {string}
     * @memberof SimplePhoto
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface SimplePhotoRequest
 */
export interface SimplePhotoRequest {
    /**
     * 
     * @type {File}
     * @memberof SimplePhotoRequest
     */
    'file': File;
}
/**
 * 
 * @export
 * @interface TokenRefresh
 */
export interface TokenRefresh {
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    'access': string;
}
/**
 * 
 * @export
 * @interface TokenRefreshRequest
 */
export interface TokenRefreshRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenRefreshRequest
     */
    'refresh': string;
}
/**
 * 
 * @export
 * @interface TopicNotificationCreateRequest
 */
export interface TopicNotificationCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof TopicNotificationCreateRequest
     */
    'receiver_type': TopicNotificationCreateRequestReceiverTypeEnum;
    /**
     * The message of the notification
     * @type {CreateNotificationMessageRequest}
     * @memberof TopicNotificationCreateRequest
     */
    'message': CreateNotificationMessageRequest;
    /**
     * 
     * @type {Array<string>}
     * @memberof TopicNotificationCreateRequest
     */
    'topic_codes': Array<string>;
}

export const TopicNotificationCreateRequestReceiverTypeEnum = {
    User: 'user',
    Topic: 'topic'
} as const;

export type TopicNotificationCreateRequestReceiverTypeEnum = typeof TopicNotificationCreateRequestReceiverTypeEnum[keyof typeof TopicNotificationCreateRequestReceiverTypeEnum];

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'uuid': string;
    /**
     * The date and time when user registered and consented to sharing data. Automatically set by server when user uploads registration.
     * @type {string}
     * @memberof User
     */
    'registration_time': string;
    /**
     * The locale code representing the language preference selected by the user for displaying the interface text. Enter the locale following the BCP 47 standard in \'language\' or \'language-region\' format (e.g., \'en\' for English, \'en-US\' for English (United States), \'fr\' for French). The language is a two-letter ISO 639-1 code, and the region is an optional two-letter ISO 3166-1 alpha-2 code.
     * @type {string}
     * @memberof User
     */
    'locale'?: UserLocaleEnum;
    /**
     * ISO 639-1 code
     * @type {string}
     * @memberof User
     */
    'language_iso': string;
    /**
     * Global XP Score. This field is updated whenever the user asks for the score, and is only stored here. The content must equal score_v2_adult + score_v2_bite + score_v2_site
     * @type {number}
     * @memberof User
     */
    'score': number;
    /**
     * Last time score was updated
     * @type {string}
     * @memberof User
     */
    'last_score_update': string;
}

export const UserLocaleEnum = {
    Es: 'es',
    Ca: 'ca',
    Eu: 'eu',
    Bn: 'bn',
    Sv: 'sv',
    En: 'en',
    De: 'de',
    Sq: 'sq',
    El: 'el',
    Gl: 'gl',
    Hu: 'hu',
    Pt: 'pt',
    Sl: 'sl',
    It: 'it',
    Fr: 'fr',
    Bg: 'bg',
    Ro: 'ro',
    Hr: 'hr',
    Mk: 'mk',
    Sr: 'sr',
    Lb: 'lb',
    Nl: 'nl',
    Tr: 'tr',
    ZhCn: 'zh-CN'
} as const;

export type UserLocaleEnum = typeof UserLocaleEnum[keyof typeof UserLocaleEnum];

/**
 * 
 * @export
 * @interface UserNotificationCreateRequest
 */
export interface UserNotificationCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof UserNotificationCreateRequest
     */
    'receiver_type': UserNotificationCreateRequestReceiverTypeEnum;
    /**
     * The message of the notification
     * @type {CreateNotificationMessageRequest}
     * @memberof UserNotificationCreateRequest
     */
    'message': CreateNotificationMessageRequest;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserNotificationCreateRequest
     */
    'user_uuids': Array<string>;
}

export const UserNotificationCreateRequestReceiverTypeEnum = {
    User: 'user',
    Topic: 'topic'
} as const;

export type UserNotificationCreateRequestReceiverTypeEnum = typeof UserNotificationCreateRequestReceiverTypeEnum[keyof typeof UserNotificationCreateRequestReceiverTypeEnum];

/**
 * 
 * @export
 * @interface UserRequest
 */
export interface UserRequest {
    /**
     * The locale code representing the language preference selected by the user for displaying the interface text. Enter the locale following the BCP 47 standard in \'language\' or \'language-region\' format (e.g., \'en\' for English, \'en-US\' for English (United States), \'fr\' for French). The language is a two-letter ISO 639-1 code, and the region is an optional two-letter ISO 3166-1 alpha-2 code.
     * @type {string}
     * @memberof UserRequest
     */
    'locale'?: UserRequestLocaleEnum;
}

export const UserRequestLocaleEnum = {
    Es: 'es',
    Ca: 'ca',
    Eu: 'eu',
    Bn: 'bn',
    Sv: 'sv',
    En: 'en',
    De: 'de',
    Sq: 'sq',
    El: 'el',
    Gl: 'gl',
    Hu: 'hu',
    Pt: 'pt',
    Sl: 'sl',
    It: 'it',
    Fr: 'fr',
    Bg: 'bg',
    Ro: 'ro',
    Hr: 'hr',
    Mk: 'mk',
    Sr: 'sr',
    Lb: 'lb',
    Nl: 'nl',
    Tr: 'tr',
    ZhCn: 'zh-CN'
} as const;

export type UserRequestLocaleEnum = typeof UserRequestLocaleEnum[keyof typeof UserRequestLocaleEnum];


/**
 * BitesApi - axios parameter creator
 * @export
 */
export const BitesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {BiteRequest} biteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bitesCreate: async (biteRequest: BiteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'biteRequest' is not null or undefined
            assertParamExists('bitesCreate', 'biteRequest', biteRequest)
            const localVarPath = `/bites/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(biteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bitesDestroy: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('bitesDestroy', 'uuid', uuid)
            const localVarPath = `/bites/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [createdAtAfter] Created at
         * @param {string} [createdAtBefore] Created at
         * @param {number | null} [locationCountryId] 
         * @param {string} [locationNuts2] 
         * @param {string} [locationNuts3] 
         * @param {Array<BitesListOrderByEnum>} [orderBy] Ordenado  
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [receivedAtAfter] Received at
         * @param {string} [receivedAtBefore] Received at
         * @param {string} [shortId] Short ID
         * @param {string} [updatedAtAfter] Update at
         * @param {string} [updatedAtBefore] Update at
         * @param {string} [userUuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bitesList: async (createdAtAfter?: string, createdAtBefore?: string, locationCountryId?: number | null, locationNuts2?: string, locationNuts3?: string, orderBy?: Array<BitesListOrderByEnum>, page?: number, pageSize?: number, receivedAtAfter?: string, receivedAtBefore?: string, shortId?: string, updatedAtAfter?: string, updatedAtBefore?: string, userUuid?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bites/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (createdAtAfter !== undefined) {
                localVarQueryParameter['created_at_after'] = (createdAtAfter as any instanceof Date) ?
                    (createdAtAfter as any).toISOString() :
                    createdAtAfter;
            }

            if (createdAtBefore !== undefined) {
                localVarQueryParameter['created_at_before'] = (createdAtBefore as any instanceof Date) ?
                    (createdAtBefore as any).toISOString() :
                    createdAtBefore;
            }

            if (locationCountryId !== undefined) {
                localVarQueryParameter['location_country_id'] = locationCountryId;
            }

            if (locationNuts2 !== undefined) {
                localVarQueryParameter['location_nuts_2'] = locationNuts2;
            }

            if (locationNuts3 !== undefined) {
                localVarQueryParameter['location_nuts_3'] = locationNuts3;
            }

            if (orderBy) {
                localVarQueryParameter['order_by'] = orderBy.join(COLLECTION_FORMATS.csv);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (receivedAtAfter !== undefined) {
                localVarQueryParameter['received_at_after'] = (receivedAtAfter as any instanceof Date) ?
                    (receivedAtAfter as any).toISOString() :
                    receivedAtAfter;
            }

            if (receivedAtBefore !== undefined) {
                localVarQueryParameter['received_at_before'] = (receivedAtBefore as any instanceof Date) ?
                    (receivedAtBefore as any).toISOString() :
                    receivedAtBefore;
            }

            if (shortId !== undefined) {
                localVarQueryParameter['short_id'] = shortId;
            }

            if (updatedAtAfter !== undefined) {
                localVarQueryParameter['updated_at_after'] = (updatedAtAfter as any instanceof Date) ?
                    (updatedAtAfter as any).toISOString() :
                    updatedAtAfter;
            }

            if (updatedAtBefore !== undefined) {
                localVarQueryParameter['updated_at_before'] = (updatedAtBefore as any instanceof Date) ?
                    (updatedAtBefore as any).toISOString() :
                    updatedAtBefore;
            }

            if (userUuid !== undefined) {
                localVarQueryParameter['user_uuid'] = userUuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bitesRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('bitesRetrieve', 'uuid', uuid)
            const localVarPath = `/bites/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BitesApi - functional programming interface
 * @export
 */
export const BitesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BitesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {BiteRequest} biteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bitesCreate(biteRequest: BiteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bitesCreate(biteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BitesApi.bitesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bitesDestroy(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bitesDestroy(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BitesApi.bitesDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [createdAtAfter] Created at
         * @param {string} [createdAtBefore] Created at
         * @param {number | null} [locationCountryId] 
         * @param {string} [locationNuts2] 
         * @param {string} [locationNuts3] 
         * @param {Array<BitesListOrderByEnum>} [orderBy] Ordenado  
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [receivedAtAfter] Received at
         * @param {string} [receivedAtBefore] Received at
         * @param {string} [shortId] Short ID
         * @param {string} [updatedAtAfter] Update at
         * @param {string} [updatedAtBefore] Update at
         * @param {string} [userUuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bitesList(createdAtAfter?: string, createdAtBefore?: string, locationCountryId?: number | null, locationNuts2?: string, locationNuts3?: string, orderBy?: Array<BitesListOrderByEnum>, page?: number, pageSize?: number, receivedAtAfter?: string, receivedAtBefore?: string, shortId?: string, updatedAtAfter?: string, updatedAtBefore?: string, userUuid?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBiteList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bitesList(createdAtAfter, createdAtBefore, locationCountryId, locationNuts2, locationNuts3, orderBy, page, pageSize, receivedAtAfter, receivedAtBefore, shortId, updatedAtAfter, updatedAtBefore, userUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BitesApi.bitesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bitesRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bitesRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BitesApi.bitesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BitesApi - factory interface
 * @export
 */
export const BitesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BitesApiFp(configuration)
    return {
        /**
         * 
         * @param {BiteRequest} biteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bitesCreate(biteRequest: BiteRequest, options?: RawAxiosRequestConfig): AxiosPromise<Bite> {
            return localVarFp.bitesCreate(biteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bitesDestroy(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.bitesDestroy(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [createdAtAfter] Created at
         * @param {string} [createdAtBefore] Created at
         * @param {number | null} [locationCountryId] 
         * @param {string} [locationNuts2] 
         * @param {string} [locationNuts3] 
         * @param {Array<BitesListOrderByEnum>} [orderBy] Ordenado  
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [receivedAtAfter] Received at
         * @param {string} [receivedAtBefore] Received at
         * @param {string} [shortId] Short ID
         * @param {string} [updatedAtAfter] Update at
         * @param {string} [updatedAtBefore] Update at
         * @param {string} [userUuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bitesList(createdAtAfter?: string, createdAtBefore?: string, locationCountryId?: number | null, locationNuts2?: string, locationNuts3?: string, orderBy?: Array<BitesListOrderByEnum>, page?: number, pageSize?: number, receivedAtAfter?: string, receivedAtBefore?: string, shortId?: string, updatedAtAfter?: string, updatedAtBefore?: string, userUuid?: string, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedBiteList> {
            return localVarFp.bitesList(createdAtAfter, createdAtBefore, locationCountryId, locationNuts2, locationNuts3, orderBy, page, pageSize, receivedAtAfter, receivedAtBefore, shortId, updatedAtAfter, updatedAtBefore, userUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bitesRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<Bite> {
            return localVarFp.bitesRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BitesApi - object-oriented interface
 * @export
 * @class BitesApi
 * @extends {BaseAPI}
 */
export class BitesApi extends BaseAPI {
    /**
     * 
     * @param {BiteRequest} biteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitesApi
     */
    public bitesCreate(biteRequest: BiteRequest, options?: RawAxiosRequestConfig) {
        return BitesApiFp(this.configuration).bitesCreate(biteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitesApi
     */
    public bitesDestroy(uuid: string, options?: RawAxiosRequestConfig) {
        return BitesApiFp(this.configuration).bitesDestroy(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [createdAtAfter] Created at
     * @param {string} [createdAtBefore] Created at
     * @param {number | null} [locationCountryId] 
     * @param {string} [locationNuts2] 
     * @param {string} [locationNuts3] 
     * @param {Array<BitesListOrderByEnum>} [orderBy] Ordenado  
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [receivedAtAfter] Received at
     * @param {string} [receivedAtBefore] Received at
     * @param {string} [shortId] Short ID
     * @param {string} [updatedAtAfter] Update at
     * @param {string} [updatedAtBefore] Update at
     * @param {string} [userUuid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitesApi
     */
    public bitesList(createdAtAfter?: string, createdAtBefore?: string, locationCountryId?: number | null, locationNuts2?: string, locationNuts3?: string, orderBy?: Array<BitesListOrderByEnum>, page?: number, pageSize?: number, receivedAtAfter?: string, receivedAtBefore?: string, shortId?: string, updatedAtAfter?: string, updatedAtBefore?: string, userUuid?: string, options?: RawAxiosRequestConfig) {
        return BitesApiFp(this.configuration).bitesList(createdAtAfter, createdAtBefore, locationCountryId, locationNuts2, locationNuts3, orderBy, page, pageSize, receivedAtAfter, receivedAtBefore, shortId, updatedAtAfter, updatedAtBefore, userUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BitesApi
     */
    public bitesRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return BitesApiFp(this.configuration).bitesRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const BitesListOrderByEnum = {
    CreatedAt: '-created_at',
    ReceivedAt: '-received_at',
    CreatedAt2: 'created_at',
    ReceivedAt2: 'received_at'
} as const;
export type BitesListOrderByEnum = typeof BitesListOrderByEnum[keyof typeof BitesListOrderByEnum];


/**
 * BreedingSitesApi - axios parameter creator
 * @export
 */
export const BreedingSitesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {BreedingSiteRequest} breedingSiteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        breedingSitesCreate: async (breedingSiteRequest: BreedingSiteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'breedingSiteRequest' is not null or undefined
            assertParamExists('breedingSitesCreate', 'breedingSiteRequest', breedingSiteRequest)
            const localVarPath = `/breeding-sites/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(breedingSiteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        breedingSitesDestroy: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('breedingSitesDestroy', 'uuid', uuid)
            const localVarPath = `/breeding-sites/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [createdAtAfter] Created at
         * @param {string} [createdAtBefore] Created at
         * @param {boolean} [hasPhotos] Has any photo
         * @param {number | null} [locationCountryId] 
         * @param {string} [locationNuts2] 
         * @param {string} [locationNuts3] 
         * @param {Array<BreedingSitesListOrderByEnum>} [orderBy] Ordenado  
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [receivedAtAfter] Received at
         * @param {string} [receivedAtBefore] Received at
         * @param {string} [shortId] Short ID
         * @param {string} [updatedAtAfter] Update at
         * @param {string} [updatedAtBefore] Update at
         * @param {string} [userUuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        breedingSitesList: async (createdAtAfter?: string, createdAtBefore?: string, hasPhotos?: boolean, locationCountryId?: number | null, locationNuts2?: string, locationNuts3?: string, orderBy?: Array<BreedingSitesListOrderByEnum>, page?: number, pageSize?: number, receivedAtAfter?: string, receivedAtBefore?: string, shortId?: string, updatedAtAfter?: string, updatedAtBefore?: string, userUuid?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/breeding-sites/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (createdAtAfter !== undefined) {
                localVarQueryParameter['created_at_after'] = (createdAtAfter as any instanceof Date) ?
                    (createdAtAfter as any).toISOString() :
                    createdAtAfter;
            }

            if (createdAtBefore !== undefined) {
                localVarQueryParameter['created_at_before'] = (createdAtBefore as any instanceof Date) ?
                    (createdAtBefore as any).toISOString() :
                    createdAtBefore;
            }

            if (hasPhotos !== undefined) {
                localVarQueryParameter['has_photos'] = hasPhotos;
            }

            if (locationCountryId !== undefined) {
                localVarQueryParameter['location_country_id'] = locationCountryId;
            }

            if (locationNuts2 !== undefined) {
                localVarQueryParameter['location_nuts_2'] = locationNuts2;
            }

            if (locationNuts3 !== undefined) {
                localVarQueryParameter['location_nuts_3'] = locationNuts3;
            }

            if (orderBy) {
                localVarQueryParameter['order_by'] = orderBy.join(COLLECTION_FORMATS.csv);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (receivedAtAfter !== undefined) {
                localVarQueryParameter['received_at_after'] = (receivedAtAfter as any instanceof Date) ?
                    (receivedAtAfter as any).toISOString() :
                    receivedAtAfter;
            }

            if (receivedAtBefore !== undefined) {
                localVarQueryParameter['received_at_before'] = (receivedAtBefore as any instanceof Date) ?
                    (receivedAtBefore as any).toISOString() :
                    receivedAtBefore;
            }

            if (shortId !== undefined) {
                localVarQueryParameter['short_id'] = shortId;
            }

            if (updatedAtAfter !== undefined) {
                localVarQueryParameter['updated_at_after'] = (updatedAtAfter as any instanceof Date) ?
                    (updatedAtAfter as any).toISOString() :
                    updatedAtAfter;
            }

            if (updatedAtBefore !== undefined) {
                localVarQueryParameter['updated_at_before'] = (updatedAtBefore as any instanceof Date) ?
                    (updatedAtBefore as any).toISOString() :
                    updatedAtBefore;
            }

            if (userUuid !== undefined) {
                localVarQueryParameter['user_uuid'] = userUuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        breedingSitesRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('breedingSitesRetrieve', 'uuid', uuid)
            const localVarPath = `/breeding-sites/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BreedingSitesApi - functional programming interface
 * @export
 */
export const BreedingSitesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BreedingSitesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {BreedingSiteRequest} breedingSiteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async breedingSitesCreate(breedingSiteRequest: BreedingSiteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BreedingSite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.breedingSitesCreate(breedingSiteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BreedingSitesApi.breedingSitesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async breedingSitesDestroy(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.breedingSitesDestroy(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BreedingSitesApi.breedingSitesDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [createdAtAfter] Created at
         * @param {string} [createdAtBefore] Created at
         * @param {boolean} [hasPhotos] Has any photo
         * @param {number | null} [locationCountryId] 
         * @param {string} [locationNuts2] 
         * @param {string} [locationNuts3] 
         * @param {Array<BreedingSitesListOrderByEnum>} [orderBy] Ordenado  
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [receivedAtAfter] Received at
         * @param {string} [receivedAtBefore] Received at
         * @param {string} [shortId] Short ID
         * @param {string} [updatedAtAfter] Update at
         * @param {string} [updatedAtBefore] Update at
         * @param {string} [userUuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async breedingSitesList(createdAtAfter?: string, createdAtBefore?: string, hasPhotos?: boolean, locationCountryId?: number | null, locationNuts2?: string, locationNuts3?: string, orderBy?: Array<BreedingSitesListOrderByEnum>, page?: number, pageSize?: number, receivedAtAfter?: string, receivedAtBefore?: string, shortId?: string, updatedAtAfter?: string, updatedAtBefore?: string, userUuid?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBreedingSiteList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.breedingSitesList(createdAtAfter, createdAtBefore, hasPhotos, locationCountryId, locationNuts2, locationNuts3, orderBy, page, pageSize, receivedAtAfter, receivedAtBefore, shortId, updatedAtAfter, updatedAtBefore, userUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BreedingSitesApi.breedingSitesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async breedingSitesRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BreedingSite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.breedingSitesRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BreedingSitesApi.breedingSitesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BreedingSitesApi - factory interface
 * @export
 */
export const BreedingSitesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BreedingSitesApiFp(configuration)
    return {
        /**
         * 
         * @param {BreedingSiteRequest} breedingSiteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        breedingSitesCreate(breedingSiteRequest: BreedingSiteRequest, options?: RawAxiosRequestConfig): AxiosPromise<BreedingSite> {
            return localVarFp.breedingSitesCreate(breedingSiteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        breedingSitesDestroy(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.breedingSitesDestroy(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [createdAtAfter] Created at
         * @param {string} [createdAtBefore] Created at
         * @param {boolean} [hasPhotos] Has any photo
         * @param {number | null} [locationCountryId] 
         * @param {string} [locationNuts2] 
         * @param {string} [locationNuts3] 
         * @param {Array<BreedingSitesListOrderByEnum>} [orderBy] Ordenado  
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [receivedAtAfter] Received at
         * @param {string} [receivedAtBefore] Received at
         * @param {string} [shortId] Short ID
         * @param {string} [updatedAtAfter] Update at
         * @param {string} [updatedAtBefore] Update at
         * @param {string} [userUuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        breedingSitesList(createdAtAfter?: string, createdAtBefore?: string, hasPhotos?: boolean, locationCountryId?: number | null, locationNuts2?: string, locationNuts3?: string, orderBy?: Array<BreedingSitesListOrderByEnum>, page?: number, pageSize?: number, receivedAtAfter?: string, receivedAtBefore?: string, shortId?: string, updatedAtAfter?: string, updatedAtBefore?: string, userUuid?: string, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedBreedingSiteList> {
            return localVarFp.breedingSitesList(createdAtAfter, createdAtBefore, hasPhotos, locationCountryId, locationNuts2, locationNuts3, orderBy, page, pageSize, receivedAtAfter, receivedAtBefore, shortId, updatedAtAfter, updatedAtBefore, userUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        breedingSitesRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<BreedingSite> {
            return localVarFp.breedingSitesRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BreedingSitesApi - object-oriented interface
 * @export
 * @class BreedingSitesApi
 * @extends {BaseAPI}
 */
export class BreedingSitesApi extends BaseAPI {
    /**
     * 
     * @param {BreedingSiteRequest} breedingSiteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BreedingSitesApi
     */
    public breedingSitesCreate(breedingSiteRequest: BreedingSiteRequest, options?: RawAxiosRequestConfig) {
        return BreedingSitesApiFp(this.configuration).breedingSitesCreate(breedingSiteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BreedingSitesApi
     */
    public breedingSitesDestroy(uuid: string, options?: RawAxiosRequestConfig) {
        return BreedingSitesApiFp(this.configuration).breedingSitesDestroy(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [createdAtAfter] Created at
     * @param {string} [createdAtBefore] Created at
     * @param {boolean} [hasPhotos] Has any photo
     * @param {number | null} [locationCountryId] 
     * @param {string} [locationNuts2] 
     * @param {string} [locationNuts3] 
     * @param {Array<BreedingSitesListOrderByEnum>} [orderBy] Ordenado  
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [receivedAtAfter] Received at
     * @param {string} [receivedAtBefore] Received at
     * @param {string} [shortId] Short ID
     * @param {string} [updatedAtAfter] Update at
     * @param {string} [updatedAtBefore] Update at
     * @param {string} [userUuid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BreedingSitesApi
     */
    public breedingSitesList(createdAtAfter?: string, createdAtBefore?: string, hasPhotos?: boolean, locationCountryId?: number | null, locationNuts2?: string, locationNuts3?: string, orderBy?: Array<BreedingSitesListOrderByEnum>, page?: number, pageSize?: number, receivedAtAfter?: string, receivedAtBefore?: string, shortId?: string, updatedAtAfter?: string, updatedAtBefore?: string, userUuid?: string, options?: RawAxiosRequestConfig) {
        return BreedingSitesApiFp(this.configuration).breedingSitesList(createdAtAfter, createdAtBefore, hasPhotos, locationCountryId, locationNuts2, locationNuts3, orderBy, page, pageSize, receivedAtAfter, receivedAtBefore, shortId, updatedAtAfter, updatedAtBefore, userUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BreedingSitesApi
     */
    public breedingSitesRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return BreedingSitesApiFp(this.configuration).breedingSitesRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const BreedingSitesListOrderByEnum = {
    CreatedAt: '-created_at',
    ReceivedAt: '-received_at',
    CreatedAt2: 'created_at',
    ReceivedAt2: 'received_at'
} as const;
export type BreedingSitesListOrderByEnum = typeof BreedingSitesListOrderByEnum[keyof typeof BreedingSitesListOrderByEnum];


/**
 * CampaignsApi - axios parameter creator
 * @export
 */
export const CampaignsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [countryId] Country in which the campaign is taking place
         * @param {boolean} [isActive] 
         * @param {Array<CampaignsListOrderByEnum>} [orderBy] Ordenado  
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsList: async (countryId?: number, isActive?: boolean, orderBy?: Array<CampaignsListOrderByEnum>, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/campaigns/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (countryId !== undefined) {
                localVarQueryParameter['country_id'] = countryId;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (orderBy) {
                localVarQueryParameter['order_by'] = orderBy.join(COLLECTION_FORMATS.csv);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ow campaigns.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('campaignsRetrieve', 'id', id)
            const localVarPath = `/campaigns/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CampaignsApi - functional programming interface
 * @export
 */
export const CampaignsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CampaignsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [countryId] Country in which the campaign is taking place
         * @param {boolean} [isActive] 
         * @param {Array<CampaignsListOrderByEnum>} [orderBy] Ordenado  
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsList(countryId?: number, isActive?: boolean, orderBy?: Array<CampaignsListOrderByEnum>, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCampaignList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsList(countryId, isActive, orderBy, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ow campaigns.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Campaign>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CampaignsApi - factory interface
 * @export
 */
export const CampaignsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CampaignsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [countryId] Country in which the campaign is taking place
         * @param {boolean} [isActive] 
         * @param {Array<CampaignsListOrderByEnum>} [orderBy] Ordenado  
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsList(countryId?: number, isActive?: boolean, orderBy?: Array<CampaignsListOrderByEnum>, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedCampaignList> {
            return localVarFp.campaignsList(countryId, isActive, orderBy, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ow campaigns.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsRetrieve(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Campaign> {
            return localVarFp.campaignsRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CampaignsApi - object-oriented interface
 * @export
 * @class CampaignsApi
 * @extends {BaseAPI}
 */
export class CampaignsApi extends BaseAPI {
    /**
     * 
     * @param {number} [countryId] Country in which the campaign is taking place
     * @param {boolean} [isActive] 
     * @param {Array<CampaignsListOrderByEnum>} [orderBy] Ordenado  
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsList(countryId?: number, isActive?: boolean, orderBy?: Array<CampaignsListOrderByEnum>, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsList(countryId, isActive, orderBy, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this ow campaigns.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CampaignsListOrderByEnum = {
    EndDate: '-end_date',
    StartDate: '-start_date',
    EndDate2: 'end_date',
    StartDate2: 'start_date'
} as const;
export type CampaignsListOrderByEnum = typeof CampaignsListOrderByEnum[keyof typeof CampaignsListOrderByEnum];


/**
 * CountriesApi - axios parameter creator
 * @export
 */
export const CountriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this europe country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('countriesRetrieve', 'id', id)
            const localVarPath = `/countries/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CountriesApi - functional programming interface
 * @export
 */
export const CountriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CountriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this europe country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countriesRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Country>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countriesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountriesApi.countriesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CountriesApi - factory interface
 * @export
 */
export const CountriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CountriesApiFp(configuration)
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this europe country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesRetrieve(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Country> {
            return localVarFp.countriesRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CountriesApi - object-oriented interface
 * @export
 * @class CountriesApi
 * @extends {BaseAPI}
 */
export class CountriesApi extends BaseAPI {
    /**
     * 
     * @param {number} id A unique integer value identifying this europe country.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    public countriesRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return CountriesApiFp(this.configuration).countriesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DevicesApi - axios parameter creator
 * @export
 */
export const DevicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DeviceRequest} deviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesCreate: async (deviceRequest: DeviceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceRequest' is not null or undefined
            assertParamExists('devicesCreate', 'deviceRequest', deviceRequest)
            const localVarPath = `/devices/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} deviceId 
         * @param {PatchedDeviceUpdateRequest} [patchedDeviceUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesPartialUpdate: async (deviceId: string, patchedDeviceUpdateRequest?: PatchedDeviceUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesPartialUpdate', 'deviceId', deviceId)
            const localVarPath = `/devices/{device_id}/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedDeviceUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} deviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesRetrieve: async (deviceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesRetrieve', 'deviceId', deviceId)
            const localVarPath = `/devices/{device_id}/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} deviceId 
         * @param {DeviceUpdateRequest} deviceUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesUpdate: async (deviceId: string, deviceUpdateRequest: DeviceUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesUpdate', 'deviceId', deviceId)
            // verify required parameter 'deviceUpdateRequest' is not null or undefined
            assertParamExists('devicesUpdate', 'deviceUpdateRequest', deviceUpdateRequest)
            const localVarPath = `/devices/{device_id}/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deviceUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DevicesApi - functional programming interface
 * @export
 */
export const DevicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DevicesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {DeviceRequest} deviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesCreate(deviceRequest: DeviceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesCreate(deviceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.devicesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} deviceId 
         * @param {PatchedDeviceUpdateRequest} [patchedDeviceUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesPartialUpdate(deviceId: string, patchedDeviceUpdateRequest?: PatchedDeviceUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesPartialUpdate(deviceId, patchedDeviceUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.devicesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} deviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesRetrieve(deviceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesRetrieve(deviceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.devicesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} deviceId 
         * @param {DeviceUpdateRequest} deviceUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesUpdate(deviceId: string, deviceUpdateRequest: DeviceUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesUpdate(deviceId, deviceUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.devicesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DevicesApi - factory interface
 * @export
 */
export const DevicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DevicesApiFp(configuration)
    return {
        /**
         * 
         * @param {DeviceRequest} deviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesCreate(deviceRequest: DeviceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Device> {
            return localVarFp.devicesCreate(deviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} deviceId 
         * @param {PatchedDeviceUpdateRequest} [patchedDeviceUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesPartialUpdate(deviceId: string, patchedDeviceUpdateRequest?: PatchedDeviceUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeviceUpdate> {
            return localVarFp.devicesPartialUpdate(deviceId, patchedDeviceUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} deviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesRetrieve(deviceId: string, options?: RawAxiosRequestConfig): AxiosPromise<Device> {
            return localVarFp.devicesRetrieve(deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} deviceId 
         * @param {DeviceUpdateRequest} deviceUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesUpdate(deviceId: string, deviceUpdateRequest: DeviceUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeviceUpdate> {
            return localVarFp.devicesUpdate(deviceId, deviceUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DevicesApi - object-oriented interface
 * @export
 * @class DevicesApi
 * @extends {BaseAPI}
 */
export class DevicesApi extends BaseAPI {
    /**
     * 
     * @param {DeviceRequest} deviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesCreate(deviceRequest: DeviceRequest, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesCreate(deviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} deviceId 
     * @param {PatchedDeviceUpdateRequest} [patchedDeviceUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesPartialUpdate(deviceId: string, patchedDeviceUpdateRequest?: PatchedDeviceUpdateRequest, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesPartialUpdate(deviceId, patchedDeviceUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} deviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesRetrieve(deviceId: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesRetrieve(deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} deviceId 
     * @param {DeviceUpdateRequest} deviceUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesUpdate(deviceId: string, deviceUpdateRequest: DeviceUpdateRequest, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesUpdate(deviceId, deviceUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FixesApi - axios parameter creator
 * @export
 */
export const FixesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {FixRequest} fixRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fixesCreate: async (fixRequest: FixRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fixRequest' is not null or undefined
            assertParamExists('fixesCreate', 'fixRequest', fixRequest)
            const localVarPath = `/fixes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fixRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FixesApi - functional programming interface
 * @export
 */
export const FixesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FixesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {FixRequest} fixRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fixesCreate(fixRequest: FixRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fix>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fixesCreate(fixRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FixesApi.fixesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FixesApi - factory interface
 * @export
 */
export const FixesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FixesApiFp(configuration)
    return {
        /**
         * 
         * @param {FixRequest} fixRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fixesCreate(fixRequest: FixRequest, options?: RawAxiosRequestConfig): AxiosPromise<Fix> {
            return localVarFp.fixesCreate(fixRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FixesApi - object-oriented interface
 * @export
 * @class FixesApi
 * @extends {BaseAPI}
 */
export class FixesApi extends BaseAPI {
    /**
     * 
     * @param {FixRequest} fixRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FixesApi
     */
    public fixesCreate(fixRequest: FixRequest, options?: RawAxiosRequestConfig) {
        return FixesApiFp(this.configuration).fixesCreate(fixRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {MetaNotificationRequest} [metaNotificationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsCreate: async (metaNotificationRequest?: MetaNotificationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notifications/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(metaNotificationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [isRead] 
         * @param {Array<NotificationsListOrderByEnum>} [orderBy] Ordenado  
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsList: async (isRead?: boolean, orderBy?: Array<NotificationsListOrderByEnum>, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notifications/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isRead !== undefined) {
                localVarQueryParameter['is_read'] = isRead;
            }

            if (orderBy) {
                localVarQueryParameter['order_by'] = orderBy.join(COLLECTION_FORMATS.csv);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this notification.
         * @param {PatchedNotificationRequest} [patchedNotificationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsPartialUpdate: async (id: number, patchedNotificationRequest?: PatchedNotificationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('notificationsPartialUpdate', 'id', id)
            const localVarPath = `/notifications/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedNotificationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this notification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('notificationsRetrieve', 'id', id)
            const localVarPath = `/notifications/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this notification.
         * @param {NotificationRequest} notificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsUpdate: async (id: number, notificationRequest: NotificationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('notificationsUpdate', 'id', id)
            // verify required parameter 'notificationRequest' is not null or undefined
            assertParamExists('notificationsUpdate', 'notificationRequest', notificationRequest)
            const localVarPath = `/notifications/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {MetaNotificationRequest} [metaNotificationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsCreate(metaNotificationRequest?: MetaNotificationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreateNotification>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsCreate(metaNotificationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.notificationsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {boolean} [isRead] 
         * @param {Array<NotificationsListOrderByEnum>} [orderBy] Ordenado  
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsList(isRead?: boolean, orderBy?: Array<NotificationsListOrderByEnum>, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedNotificationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsList(isRead, orderBy, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.notificationsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this notification.
         * @param {PatchedNotificationRequest} [patchedNotificationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsPartialUpdate(id: number, patchedNotificationRequest?: PatchedNotificationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsPartialUpdate(id, patchedNotificationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.notificationsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this notification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.notificationsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this notification.
         * @param {NotificationRequest} notificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsUpdate(id: number, notificationRequest: NotificationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsUpdate(id, notificationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.notificationsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationsApiFp(configuration)
    return {
        /**
         * 
         * @param {MetaNotificationRequest} [metaNotificationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsCreate(metaNotificationRequest?: MetaNotificationRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateNotification>> {
            return localVarFp.notificationsCreate(metaNotificationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [isRead] 
         * @param {Array<NotificationsListOrderByEnum>} [orderBy] Ordenado  
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsList(isRead?: boolean, orderBy?: Array<NotificationsListOrderByEnum>, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedNotificationList> {
            return localVarFp.notificationsList(isRead, orderBy, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this notification.
         * @param {PatchedNotificationRequest} [patchedNotificationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsPartialUpdate(id: number, patchedNotificationRequest?: PatchedNotificationRequest, options?: RawAxiosRequestConfig): AxiosPromise<Notification> {
            return localVarFp.notificationsPartialUpdate(id, patchedNotificationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this notification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsRetrieve(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Notification> {
            return localVarFp.notificationsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this notification.
         * @param {NotificationRequest} notificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsUpdate(id: number, notificationRequest: NotificationRequest, options?: RawAxiosRequestConfig): AxiosPromise<Notification> {
            return localVarFp.notificationsUpdate(id, notificationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     * 
     * @param {MetaNotificationRequest} [metaNotificationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsCreate(metaNotificationRequest?: MetaNotificationRequest, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsCreate(metaNotificationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [isRead] 
     * @param {Array<NotificationsListOrderByEnum>} [orderBy] Ordenado  
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsList(isRead?: boolean, orderBy?: Array<NotificationsListOrderByEnum>, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsList(isRead, orderBy, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this notification.
     * @param {PatchedNotificationRequest} [patchedNotificationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsPartialUpdate(id: number, patchedNotificationRequest?: PatchedNotificationRequest, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsPartialUpdate(id, patchedNotificationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this notification.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this notification.
     * @param {NotificationRequest} notificationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsUpdate(id: number, notificationRequest: NotificationRequest, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsUpdate(id, notificationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const NotificationsListOrderByEnum = {
    CreatedAt: '-created_at',
    CreatedAt2: 'created_at'
} as const;
export type NotificationsListOrderByEnum = typeof NotificationsListOrderByEnum[keyof typeof NotificationsListOrderByEnum];


/**
 * ObservationsApi - axios parameter creator
 * @export
 */
export const ObservationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ObservationRequest} observationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observationsCreate: async (observationRequest: ObservationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'observationRequest' is not null or undefined
            assertParamExists('observationsCreate', 'observationRequest', observationRequest)
            const localVarPath = `/observations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(observationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observationsDestroy: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('observationsDestroy', 'uuid', uuid)
            const localVarPath = `/observations/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [createdAtAfter] Created at
         * @param {string} [createdAtBefore] Created at
         * @param {boolean} [hasPhotos] Has any photo
         * @param {boolean} [hasPrediction] Filter observations that have an associated prediction. An observation is considered to have a prediction if a photo has been selected as reference to use the prediction from.
         * @param {boolean} [hasPredictionsAllPhotos] Filters observations based on whether all associated photos have predictions. Set to True to include observations where every photo has a prediction; set to False to include observations where at least one photo is missing a prediction.
         * @param {number | null} [locationCountryId] 
         * @param {string} [locationNuts2] 
         * @param {string} [locationNuts3] 
         * @param {Array<ObservationsListOrderByEnum>} [orderBy] Ordenado  
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [receivedAtAfter] Received at
         * @param {string} [receivedAtBefore] Received at
         * @param {string} [shortId] Short ID
         * @param {string} [updatedAtAfter] Update at
         * @param {string} [updatedAtBefore] Update at
         * @param {string} [userUuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observationsList: async (createdAtAfter?: string, createdAtBefore?: string, hasPhotos?: boolean, hasPrediction?: boolean, hasPredictionsAllPhotos?: boolean, locationCountryId?: number | null, locationNuts2?: string, locationNuts3?: string, orderBy?: Array<ObservationsListOrderByEnum>, page?: number, pageSize?: number, receivedAtAfter?: string, receivedAtBefore?: string, shortId?: string, updatedAtAfter?: string, updatedAtBefore?: string, userUuid?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/observations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (createdAtAfter !== undefined) {
                localVarQueryParameter['created_at_after'] = (createdAtAfter as any instanceof Date) ?
                    (createdAtAfter as any).toISOString() :
                    createdAtAfter;
            }

            if (createdAtBefore !== undefined) {
                localVarQueryParameter['created_at_before'] = (createdAtBefore as any instanceof Date) ?
                    (createdAtBefore as any).toISOString() :
                    createdAtBefore;
            }

            if (hasPhotos !== undefined) {
                localVarQueryParameter['has_photos'] = hasPhotos;
            }

            if (hasPrediction !== undefined) {
                localVarQueryParameter['has_prediction'] = hasPrediction;
            }

            if (hasPredictionsAllPhotos !== undefined) {
                localVarQueryParameter['has_predictions_all_photos'] = hasPredictionsAllPhotos;
            }

            if (locationCountryId !== undefined) {
                localVarQueryParameter['location_country_id'] = locationCountryId;
            }

            if (locationNuts2 !== undefined) {
                localVarQueryParameter['location_nuts_2'] = locationNuts2;
            }

            if (locationNuts3 !== undefined) {
                localVarQueryParameter['location_nuts_3'] = locationNuts3;
            }

            if (orderBy) {
                localVarQueryParameter['order_by'] = orderBy.join(COLLECTION_FORMATS.csv);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (receivedAtAfter !== undefined) {
                localVarQueryParameter['received_at_after'] = (receivedAtAfter as any instanceof Date) ?
                    (receivedAtAfter as any).toISOString() :
                    receivedAtAfter;
            }

            if (receivedAtBefore !== undefined) {
                localVarQueryParameter['received_at_before'] = (receivedAtBefore as any instanceof Date) ?
                    (receivedAtBefore as any).toISOString() :
                    receivedAtBefore;
            }

            if (shortId !== undefined) {
                localVarQueryParameter['short_id'] = shortId;
            }

            if (updatedAtAfter !== undefined) {
                localVarQueryParameter['updated_at_after'] = (updatedAtAfter as any instanceof Date) ?
                    (updatedAtAfter as any).toISOString() :
                    updatedAtAfter;
            }

            if (updatedAtBefore !== undefined) {
                localVarQueryParameter['updated_at_before'] = (updatedAtBefore as any instanceof Date) ?
                    (updatedAtBefore as any).toISOString() :
                    updatedAtBefore;
            }

            if (userUuid !== undefined) {
                localVarQueryParameter['user_uuid'] = userUuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {ObservationPredictionRequest} observationPredictionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observationsPredictionCreate: async (uuid: string, observationPredictionRequest: ObservationPredictionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('observationsPredictionCreate', 'uuid', uuid)
            // verify required parameter 'observationPredictionRequest' is not null or undefined
            assertParamExists('observationsPredictionCreate', 'observationPredictionRequest', observationPredictionRequest)
            const localVarPath = `/observations/{uuid}/prediction/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(observationPredictionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observationsPredictionDestroy: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('observationsPredictionDestroy', 'uuid', uuid)
            const localVarPath = `/observations/{uuid}/prediction/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observationsPredictionRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('observationsPredictionRetrieve', 'uuid', uuid)
            const localVarPath = `/observations/{uuid}/prediction/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observationsRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('observationsRetrieve', 'uuid', uuid)
            const localVarPath = `/observations/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ObservationsApi - functional programming interface
 * @export
 */
export const ObservationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ObservationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ObservationRequest} observationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observationsCreate(observationRequest: ObservationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Observation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observationsCreate(observationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservationsApi.observationsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observationsDestroy(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observationsDestroy(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservationsApi.observationsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [createdAtAfter] Created at
         * @param {string} [createdAtBefore] Created at
         * @param {boolean} [hasPhotos] Has any photo
         * @param {boolean} [hasPrediction] Filter observations that have an associated prediction. An observation is considered to have a prediction if a photo has been selected as reference to use the prediction from.
         * @param {boolean} [hasPredictionsAllPhotos] Filters observations based on whether all associated photos have predictions. Set to True to include observations where every photo has a prediction; set to False to include observations where at least one photo is missing a prediction.
         * @param {number | null} [locationCountryId] 
         * @param {string} [locationNuts2] 
         * @param {string} [locationNuts3] 
         * @param {Array<ObservationsListOrderByEnum>} [orderBy] Ordenado  
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [receivedAtAfter] Received at
         * @param {string} [receivedAtBefore] Received at
         * @param {string} [shortId] Short ID
         * @param {string} [updatedAtAfter] Update at
         * @param {string} [updatedAtBefore] Update at
         * @param {string} [userUuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observationsList(createdAtAfter?: string, createdAtBefore?: string, hasPhotos?: boolean, hasPrediction?: boolean, hasPredictionsAllPhotos?: boolean, locationCountryId?: number | null, locationNuts2?: string, locationNuts3?: string, orderBy?: Array<ObservationsListOrderByEnum>, page?: number, pageSize?: number, receivedAtAfter?: string, receivedAtBefore?: string, shortId?: string, updatedAtAfter?: string, updatedAtBefore?: string, userUuid?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedObservationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observationsList(createdAtAfter, createdAtBefore, hasPhotos, hasPrediction, hasPredictionsAllPhotos, locationCountryId, locationNuts2, locationNuts3, orderBy, page, pageSize, receivedAtAfter, receivedAtBefore, shortId, updatedAtAfter, updatedAtBefore, userUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservationsApi.observationsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {ObservationPredictionRequest} observationPredictionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observationsPredictionCreate(uuid: string, observationPredictionRequest: ObservationPredictionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObservationPrediction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observationsPredictionCreate(uuid, observationPredictionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservationsApi.observationsPredictionCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observationsPredictionDestroy(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observationsPredictionDestroy(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservationsApi.observationsPredictionDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observationsPredictionRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObservationPrediction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observationsPredictionRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservationsApi.observationsPredictionRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async observationsRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Observation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.observationsRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservationsApi.observationsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ObservationsApi - factory interface
 * @export
 */
export const ObservationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ObservationsApiFp(configuration)
    return {
        /**
         * 
         * @param {ObservationRequest} observationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observationsCreate(observationRequest: ObservationRequest, options?: RawAxiosRequestConfig): AxiosPromise<Observation> {
            return localVarFp.observationsCreate(observationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observationsDestroy(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.observationsDestroy(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [createdAtAfter] Created at
         * @param {string} [createdAtBefore] Created at
         * @param {boolean} [hasPhotos] Has any photo
         * @param {boolean} [hasPrediction] Filter observations that have an associated prediction. An observation is considered to have a prediction if a photo has been selected as reference to use the prediction from.
         * @param {boolean} [hasPredictionsAllPhotos] Filters observations based on whether all associated photos have predictions. Set to True to include observations where every photo has a prediction; set to False to include observations where at least one photo is missing a prediction.
         * @param {number | null} [locationCountryId] 
         * @param {string} [locationNuts2] 
         * @param {string} [locationNuts3] 
         * @param {Array<ObservationsListOrderByEnum>} [orderBy] Ordenado  
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [receivedAtAfter] Received at
         * @param {string} [receivedAtBefore] Received at
         * @param {string} [shortId] Short ID
         * @param {string} [updatedAtAfter] Update at
         * @param {string} [updatedAtBefore] Update at
         * @param {string} [userUuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observationsList(createdAtAfter?: string, createdAtBefore?: string, hasPhotos?: boolean, hasPrediction?: boolean, hasPredictionsAllPhotos?: boolean, locationCountryId?: number | null, locationNuts2?: string, locationNuts3?: string, orderBy?: Array<ObservationsListOrderByEnum>, page?: number, pageSize?: number, receivedAtAfter?: string, receivedAtBefore?: string, shortId?: string, updatedAtAfter?: string, updatedAtBefore?: string, userUuid?: string, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedObservationList> {
            return localVarFp.observationsList(createdAtAfter, createdAtBefore, hasPhotos, hasPrediction, hasPredictionsAllPhotos, locationCountryId, locationNuts2, locationNuts3, orderBy, page, pageSize, receivedAtAfter, receivedAtBefore, shortId, updatedAtAfter, updatedAtBefore, userUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {ObservationPredictionRequest} observationPredictionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observationsPredictionCreate(uuid: string, observationPredictionRequest: ObservationPredictionRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObservationPrediction> {
            return localVarFp.observationsPredictionCreate(uuid, observationPredictionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observationsPredictionDestroy(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.observationsPredictionDestroy(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observationsPredictionRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<ObservationPrediction> {
            return localVarFp.observationsPredictionRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        observationsRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<Observation> {
            return localVarFp.observationsRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ObservationsApi - object-oriented interface
 * @export
 * @class ObservationsApi
 * @extends {BaseAPI}
 */
export class ObservationsApi extends BaseAPI {
    /**
     * 
     * @param {ObservationRequest} observationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservationsApi
     */
    public observationsCreate(observationRequest: ObservationRequest, options?: RawAxiosRequestConfig) {
        return ObservationsApiFp(this.configuration).observationsCreate(observationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservationsApi
     */
    public observationsDestroy(uuid: string, options?: RawAxiosRequestConfig) {
        return ObservationsApiFp(this.configuration).observationsDestroy(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [createdAtAfter] Created at
     * @param {string} [createdAtBefore] Created at
     * @param {boolean} [hasPhotos] Has any photo
     * @param {boolean} [hasPrediction] Filter observations that have an associated prediction. An observation is considered to have a prediction if a photo has been selected as reference to use the prediction from.
     * @param {boolean} [hasPredictionsAllPhotos] Filters observations based on whether all associated photos have predictions. Set to True to include observations where every photo has a prediction; set to False to include observations where at least one photo is missing a prediction.
     * @param {number | null} [locationCountryId] 
     * @param {string} [locationNuts2] 
     * @param {string} [locationNuts3] 
     * @param {Array<ObservationsListOrderByEnum>} [orderBy] Ordenado  
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [receivedAtAfter] Received at
     * @param {string} [receivedAtBefore] Received at
     * @param {string} [shortId] Short ID
     * @param {string} [updatedAtAfter] Update at
     * @param {string} [updatedAtBefore] Update at
     * @param {string} [userUuid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservationsApi
     */
    public observationsList(createdAtAfter?: string, createdAtBefore?: string, hasPhotos?: boolean, hasPrediction?: boolean, hasPredictionsAllPhotos?: boolean, locationCountryId?: number | null, locationNuts2?: string, locationNuts3?: string, orderBy?: Array<ObservationsListOrderByEnum>, page?: number, pageSize?: number, receivedAtAfter?: string, receivedAtBefore?: string, shortId?: string, updatedAtAfter?: string, updatedAtBefore?: string, userUuid?: string, options?: RawAxiosRequestConfig) {
        return ObservationsApiFp(this.configuration).observationsList(createdAtAfter, createdAtBefore, hasPhotos, hasPrediction, hasPredictionsAllPhotos, locationCountryId, locationNuts2, locationNuts3, orderBy, page, pageSize, receivedAtAfter, receivedAtBefore, shortId, updatedAtAfter, updatedAtBefore, userUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {ObservationPredictionRequest} observationPredictionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservationsApi
     */
    public observationsPredictionCreate(uuid: string, observationPredictionRequest: ObservationPredictionRequest, options?: RawAxiosRequestConfig) {
        return ObservationsApiFp(this.configuration).observationsPredictionCreate(uuid, observationPredictionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservationsApi
     */
    public observationsPredictionDestroy(uuid: string, options?: RawAxiosRequestConfig) {
        return ObservationsApiFp(this.configuration).observationsPredictionDestroy(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservationsApi
     */
    public observationsPredictionRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return ObservationsApiFp(this.configuration).observationsPredictionRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservationsApi
     */
    public observationsRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return ObservationsApiFp(this.configuration).observationsRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ObservationsListOrderByEnum = {
    CreatedAt: '-created_at',
    ReceivedAt: '-received_at',
    CreatedAt2: 'created_at',
    ReceivedAt2: 'received_at'
} as const;
export type ObservationsListOrderByEnum = typeof ObservationsListOrderByEnum[keyof typeof ObservationsListOrderByEnum];


/**
 * PartnersApi - axios parameter creator
 * @export
 */
export const PartnersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnersList: async (page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/partners/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this organization pin.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnersRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partnersRetrieve', 'id', id)
            const localVarPath = `/partners/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartnersApi - functional programming interface
 * @export
 */
export const PartnersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PartnersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnersList(page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPartnerList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnersList(page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnersApi.partnersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this organization pin.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnersRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Partner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnersRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnersApi.partnersRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PartnersApi - factory interface
 * @export
 */
export const PartnersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PartnersApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnersList(page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedPartnerList> {
            return localVarFp.partnersList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this organization pin.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnersRetrieve(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Partner> {
            return localVarFp.partnersRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PartnersApi - object-oriented interface
 * @export
 * @class PartnersApi
 * @extends {BaseAPI}
 */
export class PartnersApi extends BaseAPI {
    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnersApi
     */
    public partnersList(page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return PartnersApiFp(this.configuration).partnersList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this organization pin.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnersApi
     */
    public partnersRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return PartnersApiFp(this.configuration).partnersRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PhotosApi - axios parameter creator
 * @export
 */
export const PhotosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} uuid 
         * @param {PhotoPredictionRequest} photoPredictionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        photosPredictionCreate: async (uuid: string, photoPredictionRequest: PhotoPredictionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('photosPredictionCreate', 'uuid', uuid)
            // verify required parameter 'photoPredictionRequest' is not null or undefined
            assertParamExists('photosPredictionCreate', 'photoPredictionRequest', photoPredictionRequest)
            const localVarPath = `/photos/{uuid}/prediction/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(photoPredictionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        photosPredictionDestroy: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('photosPredictionDestroy', 'uuid', uuid)
            const localVarPath = `/photos/{uuid}/prediction/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        photosPredictionRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('photosPredictionRetrieve', 'uuid', uuid)
            const localVarPath = `/photos/{uuid}/prediction/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        photosRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('photosRetrieve', 'uuid', uuid)
            const localVarPath = `/photos/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PhotosApi - functional programming interface
 * @export
 */
export const PhotosApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PhotosApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} uuid 
         * @param {PhotoPredictionRequest} photoPredictionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async photosPredictionCreate(uuid: string, photoPredictionRequest: PhotoPredictionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PhotoPrediction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.photosPredictionCreate(uuid, photoPredictionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PhotosApi.photosPredictionCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async photosPredictionDestroy(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.photosPredictionDestroy(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PhotosApi.photosPredictionDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async photosPredictionRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PhotoPrediction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.photosPredictionRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PhotosApi.photosPredictionRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async photosRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Photo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.photosRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PhotosApi.photosRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PhotosApi - factory interface
 * @export
 */
export const PhotosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PhotosApiFp(configuration)
    return {
        /**
         * 
         * @param {string} uuid 
         * @param {PhotoPredictionRequest} photoPredictionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        photosPredictionCreate(uuid: string, photoPredictionRequest: PhotoPredictionRequest, options?: RawAxiosRequestConfig): AxiosPromise<PhotoPrediction> {
            return localVarFp.photosPredictionCreate(uuid, photoPredictionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        photosPredictionDestroy(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.photosPredictionDestroy(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        photosPredictionRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<PhotoPrediction> {
            return localVarFp.photosPredictionRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        photosRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<Photo> {
            return localVarFp.photosRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PhotosApi - object-oriented interface
 * @export
 * @class PhotosApi
 * @extends {BaseAPI}
 */
export class PhotosApi extends BaseAPI {
    /**
     * 
     * @param {string} uuid 
     * @param {PhotoPredictionRequest} photoPredictionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotosApi
     */
    public photosPredictionCreate(uuid: string, photoPredictionRequest: PhotoPredictionRequest, options?: RawAxiosRequestConfig) {
        return PhotosApiFp(this.configuration).photosPredictionCreate(uuid, photoPredictionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotosApi
     */
    public photosPredictionDestroy(uuid: string, options?: RawAxiosRequestConfig) {
        return PhotosApiFp(this.configuration).photosPredictionDestroy(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotosApi
     */
    public photosPredictionRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return PhotosApiFp(this.configuration).photosPredictionRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotosApi
     */
    public photosRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return PhotosApiFp(this.configuration).photosRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TokenApi - axios parameter creator
 * @export
 */
export const TokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {AppUserTokenObtainPairRequest} appUserTokenObtainPairRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenCreate: async (appUserTokenObtainPairRequest: AppUserTokenObtainPairRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appUserTokenObtainPairRequest' is not null or undefined
            assertParamExists('tokenCreate', 'appUserTokenObtainPairRequest', appUserTokenObtainPairRequest)
            const localVarPath = `/token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(appUserTokenObtainPairRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefreshRequest} tokenRefreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenRefreshCreate: async (tokenRefreshRequest: TokenRefreshRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRefreshRequest' is not null or undefined
            assertParamExists('tokenRefreshCreate', 'tokenRefreshRequest', tokenRefreshRequest)
            const localVarPath = `/token/refresh/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRefreshRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenApi - functional programming interface
 * @export
 */
export const TokenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokenApiAxiosParamCreator(configuration)
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {AppUserTokenObtainPairRequest} appUserTokenObtainPairRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenCreate(appUserTokenObtainPairRequest: AppUserTokenObtainPairRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppUserTokenObtainPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenCreate(appUserTokenObtainPairRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TokenApi.tokenCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefreshRequest} tokenRefreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenRefreshCreate(tokenRefreshRequest: TokenRefreshRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenRefresh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenRefreshCreate(tokenRefreshRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TokenApi.tokenRefreshCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TokenApi - factory interface
 * @export
 */
export const TokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokenApiFp(configuration)
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {AppUserTokenObtainPairRequest} appUserTokenObtainPairRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenCreate(appUserTokenObtainPairRequest: AppUserTokenObtainPairRequest, options?: RawAxiosRequestConfig): AxiosPromise<AppUserTokenObtainPair> {
            return localVarFp.tokenCreate(appUserTokenObtainPairRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefreshRequest} tokenRefreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenRefreshCreate(tokenRefreshRequest: TokenRefreshRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenRefresh> {
            return localVarFp.tokenRefreshCreate(tokenRefreshRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokenApi - object-oriented interface
 * @export
 * @class TokenApi
 * @extends {BaseAPI}
 */
export class TokenApi extends BaseAPI {
    /**
     * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
     * @param {AppUserTokenObtainPairRequest} appUserTokenObtainPairRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    public tokenCreate(appUserTokenObtainPairRequest: AppUserTokenObtainPairRequest, options?: RawAxiosRequestConfig) {
        return TokenApiFp(this.configuration).tokenCreate(appUserTokenObtainPairRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
     * @param {TokenRefreshRequest} tokenRefreshRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    public tokenRefreshCreate(tokenRefreshRequest: TokenRefreshRequest, options?: RawAxiosRequestConfig) {
        return TokenApiFp(this.configuration).tokenRefreshCreate(tokenRefreshRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreate: async (createUserRequest: CreateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserRequest' is not null or undefined
            assertParamExists('usersCreate', 'createUserRequest', createUserRequest)
            const localVarPath = `/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {PatchedUserRequest} [patchedUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPartialUpdate: async (uuid: string, patchedUserRequest?: PatchedUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('usersPartialUpdate', 'uuid', uuid)
            const localVarPath = `/users/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('usersRetrieve', 'uuid', uuid)
            const localVarPath = `/users/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {UserRequest} [userRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdate: async (uuid: string, userRequest?: UserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('usersUpdate', 'uuid', uuid)
            const localVarPath = `/users/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersCreate(createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersCreate(createUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {PatchedUserRequest} [patchedUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPartialUpdate(uuid: string, patchedUserRequest?: PatchedUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPartialUpdate(uuid, patchedUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {UserRequest} [userRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUpdate(uuid: string, userRequest?: UserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUpdate(uuid, userRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreate(createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateUser> {
            return localVarFp.usersCreate(createUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {PatchedUserRequest} [patchedUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPartialUpdate(uuid: string, patchedUserRequest?: PatchedUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersPartialUpdate(uuid, patchedUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {UserRequest} [userRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdate(uuid: string, userRequest?: UserRequest, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersUpdate(uuid, userRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @param {CreateUserRequest} createUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersCreate(createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersCreate(createUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {PatchedUserRequest} [patchedUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPartialUpdate(uuid: string, patchedUserRequest?: PatchedUserRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersPartialUpdate(uuid, patchedUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {UserRequest} [userRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUpdate(uuid: string, userRequest?: UserRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUpdate(uuid, userRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



